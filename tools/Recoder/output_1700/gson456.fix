{
          "0": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 1)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "1": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 2)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "2": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 1) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "3": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 1) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "4": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 2) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "5": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 1)]);\n  }",
          "6": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 2) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "7": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 2)]);\n  }",
          "8": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS);\n  }",
          "9": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "10": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(surrogates).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "11": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(surrogates);\n  }",
          "12": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "13": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(surrogates).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "14": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(surrogates).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "15": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nreturn;\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) | 15])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);  }",
          "16": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "17": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(surrogates & 0xf)]);\n  }",
          "18": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(codePoint).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "19": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(codePoint);\n  }",
          "20": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(out);\n  }",
          "21": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(out).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "22": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nappendHexJavaScriptRepresentation(surrogates[1], out);\n  }",
          "23": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 12)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "24": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nappendHexJavaScriptRepresentation(surrogates[1], out);\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) | 15])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);  }",
          "25": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nappendHexJavaScriptRepresentation(surrogates[0], out);\n  }",
          "26": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(out).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "27": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "28": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(codePoint).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "29": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[((codePoint >>> 12) | 15)]);\n  }",
          "30": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nappendHexJavaScriptRepresentation(surrogates[0], out);\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) | 15])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);  }",
          "31": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "32": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(out).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "33": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(codePoint[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "34": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(codePoint[((codePoint >>> 12) | 15)]);\n  }",
          "35": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append().append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "36": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append();\n  }",
          "37": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 0)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "38": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(codePoint[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "39": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(codePoint).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "40": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "41": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(codePoint[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "42": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "43": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(codePoint[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "44": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append().append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "45": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(codePoint[(codePoint & 0xf)]);\n  }",
          "46": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 0) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "47": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 0) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "48": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(codePoint[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "49": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nif(Character.isSupplementaryCodePoint(codePoint)){\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) | 15])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n}\n        .append(HEX_CHARS[codePoint & 0xf]);  }",
          "50": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "51": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 15) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "52": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 8)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "53": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "54": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nbreak;\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) | 15])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);  }",
          "55": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "56": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "57": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "58": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "59": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "60": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "61": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "62": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "63": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "64": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "65": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "66": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "67": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "68": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "69": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "70": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "71": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "72": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "73": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "74": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "75": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]);\n  }",
          "76": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]);\n  }",
          "77": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "78": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "79": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "80": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "81": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "82": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "83": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "84": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]);\n  }",
          "85": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "86": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "87": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "88": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "89": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "90": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "91": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]);\n  }",
          "92": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 8) & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]);\n  }",
          "93": "  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\nout.append(\"null\").append(HEX_CHARS[((codePoint >>> 12) | 15)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[(codePoint & 0xf)]).append(HEX_CHARS[((codePoint >>> 4) & 0xf)]);\n  }"
}