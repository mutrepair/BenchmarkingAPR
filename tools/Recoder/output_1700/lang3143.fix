{
          "0": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = 2,i = 2;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "1": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i <= ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "2": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i >= ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "3": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\noccurrences.put(v, new MutableInt(1));\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "4": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found != null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "5": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found != 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "6": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i > ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "7": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(found < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "8": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\ncount.increment();\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "9": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < found);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "10": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "11": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfound = indexOf(array, v, found);\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "12": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "13": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nbreak;\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "14": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\n(final T v = ;\n:values)                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "15": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "16": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\n(final Map e = ;\n:occurrences.entrySet())                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "17": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);found) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "18": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "19": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\ntoRemove.set(found++);\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "20": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "21": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(v < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "22": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found == null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "23": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < v);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "24": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "25": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = false,i = false;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "26": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "27": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < i);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "28": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = null,i = null;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "29": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = 0,i = 0;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "30": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "31": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found == null)){\ncontinue;\n}            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "32": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);v) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "33": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i == ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "34": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found == 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "35": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfound++;\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "36": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -2,i = -2;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "37": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "38": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "39": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((v != null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "40": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((v != 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "41": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nreturn result;            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "42": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nreturn;\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "43": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = \"null\",i = \"null\";(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "44": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = true,i = true;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "45": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i - ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "46": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((i != null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "47": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(toRemove < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "48": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((i != 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "49": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "50": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\n(final Map e = ;\n:occurrences.entrySet())            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "51": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found < 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "52": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(e < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "53": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "54": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = 1,i = 1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "55": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < toRemove);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "56": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < e);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "57": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "58": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found == 0)){\ncontinue;\n}            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "59": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\ncontinue;\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "60": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((toRemove != 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "61": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((count == null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "62": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((toRemove != null)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "63": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "64": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\n(final T v = ;\n:values)            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "65": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "66": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);toRemove) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "67": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);e) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "68": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nif((found > 0)){\n            for (int i = -1, ct = e.getValue().intValue(); i < ct; i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n}\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "69": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "70": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i >> ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "71": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i != ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "72": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\nfor(int i = -1,i = -1;(i < ct);i++) {                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }",
          "73": "    public static <T> T[] removeElements(final T[] array, final T... values) {\n        if (isEmpty(array) || isEmpty(values)) {\n            return clone(array);\n        }\n        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n        for (final T v : values) {\n            final MutableInt count = occurrences.get(v);\n            if (count == null) {\n                occurrences.put(v, new MutableInt(1));\n            } else {\n                count.increment();\n            }\n        }\n        final BitSet toRemove = new BitSet();\n        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n            final T v = e.getKey();\n            int found = 0;\n((i < (i < ct)))                found = indexOf(array, v, found);\n                if (found < 0) {\n                    break;\n                }\n                toRemove.set(found++);\n            }\n        }\n        @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n        final\n        T[] result = (T[]) removeAll(array, toRemove);\n        return result;\n    }"
}