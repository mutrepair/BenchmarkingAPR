{
          "0": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateUsage(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "1": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(isContainedInGoogDefineClass(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "2": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "3": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(isGoogDefineClass(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "4": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "5": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, GOOG_CLASS_STATICS_NOT_VALID)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "6": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "7": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(!validateObjLit(staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "8": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(description, \"null\")){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "9": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(staticsProp){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "10": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit()){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "11": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(staticsProp.validateObjLit()){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "12": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(staticsProp.isFunction()){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "13": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(!staticsProp){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "14": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "15": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "16": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, false)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "17": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "18": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(extractClassDefinition(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "19": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(isFunction(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "20": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(((staticsProp != null) && validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "21": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, true)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "22": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit()){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "23": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(extractProperty(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "24": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, )){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "25": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((staticsProp || validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "26": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((staticsProp != null)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "27": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(compiler.validateObjLit(staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "28": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((staticsProp && validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "29": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "30": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(JSError.validateObjLit(staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "31": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((statics == null)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "32": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(staticsProp.validateObjLit(staticsProp)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "33": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(((staticsProp != null) || validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "34": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nreturn null;      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "35": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && (staticsProp != null))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "36": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, null)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "37": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((staticsProp != null)){\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n}\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "38": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(!validateObjLit(staticsProp, GOOG_CLASS_STATICS_NOT_VALID)){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "39": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, \"null\")){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "40": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp.isFunction())){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "41": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(staticsProp, )){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "42": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || validateObjLit(name))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "43": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || validateObjLit(value))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "44": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || validateObjLit(superClass))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "45": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || validateObjLit(classModifier))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "46": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(make(staticsProp)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "47": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit()){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "48": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nstatics = staticsProp;\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "49": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\ncompiler.report(JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "50": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nclassModifier = staticsProp;\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n}\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "51": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(name))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "52": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(value))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "53": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(superClass))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "54": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(classModifier))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "55": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(((staticsProp == null) && validateObjLit(staticsProp))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "56": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(description)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "57": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(staticsProp.isFunction()){\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n}\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "58": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && (staticsProp == null))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "59": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || (staticsProp != null))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "60": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) || (staticsProp == null))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "61": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit()){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "62": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit()){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "63": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif(validateObjLit(statics)){        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "64": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nstatics = IR.objectlit();\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "65": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(staticsProp, false))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "66": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nif((validateObjLit(staticsProp) && validateObjLit(staticsProp, true))){\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "67": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nreturn;\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "68": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nbreak;\n      if (validateObjLit(staticsProp)) {        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "69": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\ncompiler.report(JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }",
          "70": "  private ClassDefinition extractClassDefinition(\n      Node targetName, Node callNode) {\n\n    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n    if (superClass == null ||\n        (!superClass.isNull() && !superClass.isQualifiedName())) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n      return null;\n    }\n    if (NodeUtil.isNullOrUndefined(superClass)) {\n      superClass = null;\n    }\n\n    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n    if (description == null\n        || !description.isObjectLit()\n        || !validateObjLit(description)) {\n      // report bad class definition\n      compiler.report(JSError.make(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n      return null;\n    }\n\n    int paramCount = callNode.getChildCount() -1;\n    if (paramCount > 2) {\n      compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n      return null;\n    }\n\n    Node constructor = extractProperty(description, \"constructor\");\n    if (constructor == null) {\n      // report missing constructor\n      compiler.report(JSError.make(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n      return null;\n    }\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n\n    Node classModifier = null;\n    Node statics = null;\n    Node staticsProp = extractProperty(description, \"statics\");\n    if (staticsProp != null) {\nclassModifier = staticsProp;\n        statics = staticsProp;\n      } else if (staticsProp.isFunction()) {\n        classModifier = staticsProp;\n      } else {\n        compiler.report(\n            JSError.make(staticsProp, GOOG_CLASS_STATICS_NOT_VALID));\n        return null;\n      }\n    }\n\n    if (statics == null) {\n      statics = IR.objectlit();\n    }\n\n    // Ok, now rip apart the definition into its component pieces.\n    // Remove the \"special\" property key nodes.\n    maybeDetach(constructor.getParent());\n    maybeDetach(statics.getParent());\n    if (classModifier != null) {\n      maybeDetach(classModifier.getParent());\n    }\n    ClassDefinition def = new ClassDefinition(\n        targetName,\n        maybeDetach(superClass),\n        new MemberDefinition(info, null, maybeDetach(constructor)),\n        objectLitToList(maybeDetach(statics)),\n        objectLitToList(description),\n        maybeDetach(classModifier));\n    return def;\n  }"
}