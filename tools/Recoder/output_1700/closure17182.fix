{
          "0": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations >= maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "1": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations <= maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "2": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "3": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations == maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "4": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nreturn;\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "5": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((scope > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "6": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations < maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "7": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, iterations);\n    } while (changed);\n  }",
          "8": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations != maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "9": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((changed > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "10": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations));\n    } while (changed);\n  }",
          "11": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((workList > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "12": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nbreak;\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "13": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((NON_HALTING_ERROR_MSG > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "14": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((maxIterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "15": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nworkList.add(varScope);\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "16": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nchanged = false;\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "17": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nworkSet.add(varScope);\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "18": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nchanged = true;\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "19": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), workList);\n    } while (changed);\n  }",
          "20": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((i > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "21": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((topScope > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "22": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((-iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "23": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > scope), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "24": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(iterations, (++iterations > maxIterations));\n    } while (changed);\n  }",
          "25": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(iterations, NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "26": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), changed);\n    } while (changed);\n  }",
          "27": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ncheckState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "28": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((workSet > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "29": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((-NON_HALTING_ERROR_MSG > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "30": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), name);\n    } while (changed);\n  }",
          "31": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), propName);\n    } while (changed);\n  }",
          "32": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), workSet);\n    } while (changed);\n  }",
          "33": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), scope);\n    } while (changed);\n  }",
          "34": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > changed), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "35": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), i);\n    } while (changed);\n  }",
          "36": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), maxIterations);\n    } while (changed);\n  }",
          "37": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations));\n    } while (changed);\n  }",
          "38": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ntopScope.initForScopeRoot(jsRoot);\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "39": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), topScope);\n    } while (changed);\n  }",
          "40": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), -iterations);\n    } while (changed);\n  }",
          "41": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > workList), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "42": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), jsRoot);\n    } while (changed);\n  }",
          "43": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.add((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "44": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > NON_HALTING_ERROR_MSG), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "45": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, iterations, (++iterations > maxIterations));\n    } while (changed);\n  }",
          "46": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((-maxIterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "47": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ncontinue;\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "48": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ntopScope.initForExternRoot(externRoot);\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "49": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > i), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "50": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState();\n    } while (changed);\n  }",
          "51": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((!iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "52": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > topScope), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "53": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(varScope);\n    } while (changed);\n  }",
          "54": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.initForExternRoot((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "55": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > maxIterations), -NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "56": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nworkSet.add(varScope);\n    } while (changed);\n  }",
          "57": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "58": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nchanged = false;\n    } while (changed);\n  }",
          "59": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nif((++iterations > maxIterations)){\n      Preconditions.checkState(++iterations > maxIterations,\n}\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "60": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nassign.slot.checkState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "61": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.initForScopeRoot((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "62": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((-workSet > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "63": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations), (++iterations > maxIterations));\n    } while (changed);\n  }",
          "64": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ntopScope = new ConcreteScope(null);\n      Preconditions.checkState(++iterations > maxIterations,\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "65": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > -iterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "66": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations - maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "67": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations), iterations);\n    } while (changed);\n  }",
          "68": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations), false);\n    } while (changed);\n  }",
          "69": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nchanged = true;\n    } while (changed);\n  }",
          "70": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((!NON_HALTING_ERROR_MSG > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "71": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState((++iterations > action), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "72": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\n    } while (changed);\n  }",
          "73": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations), true);\n    } while (changed);\n  }",
          "74": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(iterations, iterations);\n    } while (changed);\n  }",
          "75": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, iterations, false);\n    } while (changed);\n  }",
          "76": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, workSet);\n    } while (changed);\n  }",
          "77": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, maxIterations);\n    } while (changed);\n  }",
          "78": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nSets.checkState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "79": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nLists.checkState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "80": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\ntopScope.checkState((++iterations > maxIterations), NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "81": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, (++iterations > maxIterations), workSet);\n    } while (changed);\n  }",
          "82": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nif(assign.slot.addConcreteType(assign.type)){\n      Preconditions.checkState(++iterations > maxIterations,\n}\n          NON_HALTING_ERROR_MSG);    } while (changed);\n  }",
          "83": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, iterations, NON_HALTING_ERROR_MSG);\n    } while (changed);\n  }",
          "84": "  public void process(Node externRoot, Node jsRoot) {\n    // Create the scope of top-level variables and functions.\n    topScope = new ConcreteScope(null);\n    topScope.initForExternRoot(externRoot);\n    topScope.initForScopeRoot(jsRoot);\n\n    // Process the assignments in each scope in the working set until no more\n    // changes are detected.  Each time a new scope is discovered (starting with\n    // the top-level scope), it is added to the working set to be processed.\n    // Since changes in almost any scope can affect another, we iterate over all\n    // discovered scopes until no further changes occur.\n\n    long maxIterations = 1000;\n    long iterations = 0;\n\n    Set<ConcreteScope> workSet = Sets.newHashSet(topScope);\n    List<ConcreteScope> workList = Lists.newArrayList(topScope);\n\n    boolean changed;\n    do {\n      changed = false;\n      for (int i = 0; i < workList.size(); ++i) {\n        ConcreteScope scope = workList.get(i);\n        for (Action action : scope.getActions()) {\n          for (Assignment assign : action.getAssignments(scope)) {\n            if (assign.slot.addConcreteType(assign.type)) {\n              changed = true;\n              ConcreteScope varScope = assign.slot.getScope();\n              if ((varScope != scope) && !workSet.contains(varScope)) {\n                workSet.add(varScope);\n                workList.add(varScope);\n              }\n            }\n          }\n        }\n      }\nPreconditions.checkState(NON_HALTING_ERROR_MSG, iterations, true);\n    } while (changed);\n  }"
}