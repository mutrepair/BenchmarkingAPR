{
          "0": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 1)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "1": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 2)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "2": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | -1)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "3": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 0)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "4": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 0xFF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "5": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "6": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "7": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "8": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "9": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi >> 4)];\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "10": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "11": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi[(hi >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "12": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nch &= 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "13": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ptr[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "14": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "15": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = \"null\";\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "16": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "17": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(ch >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "18": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi[(ch >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "19": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputBuffer[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "20": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _entityBuffer[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "21": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nreturn;\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "22": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi[(ch & 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "23": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "24": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf[(hi >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "25": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf = _allocateEntityBuffer();\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "26": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n_outputHead = _outputTail;\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "27": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(ch >> 4)];\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "28": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(ch & 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "29": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf;\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "30": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(ch & 0xF)];\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "31": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "32": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf[(ch >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "33": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "34": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = buf[(ch & 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "35": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbreak;\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "36": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = hi;\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "37": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | -2)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "38": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputHead[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "39": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = [(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "40": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (hi | 15);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "41": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputHead[(ch >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "42": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputHead[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "43": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputHead[(hi >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "44": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputHead[(ch & 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "45": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ch[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "46": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ptr[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "47": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputTail[(ch & 0xF)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "48": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = _outputTail[(ch >> 4)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "49": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi | 1)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "50": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nif((buf == null)){\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n}\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "51": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi - 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "52": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = \"null\";\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "53": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nch &= 0xFF;\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "54": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf = _allocateEntityBuffer();\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "55": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi & 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "56": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi <= 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "57": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi < 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "58": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi * 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "59": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = HEX_CHARS[(hi + 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "60": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[ptr] = \"null\";\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "61": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n_outputHead = ptr;\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "62": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\ncontinue;\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "63": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    buf[++ptr] = HEX_CHARS[hi | 15];                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "64": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nreturn;\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "65": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[(hi | 15)] | HEX_CHARS[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "66": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[(hi | 15)] + HEX_CHARS[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "67": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[(hi | 15)] * HEX_CHARS[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "68": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[(hi | 15)] | hi[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "69": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[++ptr] | HEX_CHARS[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "70": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (HEX_CHARS[(hi | 15)] + hi[(hi | 15)]);\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "71": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)] && (hi | 15)))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "72": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = (((hi | 15) && (hi | 15)))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "73": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] += ((HEX_CHARS[(hi | 15)] && (hi | 15)))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "74": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)].[(hi | 15)] && HEX_CHARS[(hi | 15)]))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "75": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] += ((HEX_CHARS[(hi | 15)].[(hi | 15)] && HEX_CHARS[(hi | 15)]))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "76": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)].[(hi | 15)] && HEX_CHARS[(hi | 15)]))?HEX_CHARS[(hi | 15)]:HEX_CHARS[++ptr];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "77": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)].[(hi | 15)] && HEX_CHARS[(hi | 15)]))?HEX_CHARS[(hi | 15)]:hi[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "78": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)].[(hi | 15)] && (HEX_CHARS[(hi | 15)] != HEX_CHARS[(hi | 15)])))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }",
          "79": "    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\nbuf[++ptr] = ((HEX_CHARS[(hi | 15)].[(hi | 15)] && (HEX_CHARS[(hi | 15)] == HEX_CHARS[(hi | 15)])))?HEX_CHARS[(hi | 15)]:HEX_CHARS[(hi | 15)];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }"
}