{
          "0": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset - len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "1": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "2": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset >> len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "3": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset % len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "4": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "5": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset << len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "6": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset >>> len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "7": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset <= len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "8": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset / offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "9": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset & len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "10": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nlong end = (offset / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "11": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint end = (offset + len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "12": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "13": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nprintln();\n        int end = offset / len;\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "14": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nflush();\n        int end = offset / len;\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "15": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nprintSep();\n        int end = offset / len;\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "16": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nfinal int end = (offset / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "17": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "18": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset / offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "19": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "20": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset - offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "21": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / len) * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "22": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset % offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "23": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset - len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "24": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (len * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "25": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (len / offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "26": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / len) / offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "27": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "28": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (len - offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "29": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset % len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "30": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (offset / offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "31": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = (len * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "32": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / offset) * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "33": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset * offset) * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "34": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / offset) / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "35": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nreturn;\n        int end = offset / len;\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "36": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset * offset) / len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "37": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / len) * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "38": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / offset) - len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "39": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / offset) * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "40": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((len / offset) * len);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "41": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset / offset) * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "42": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\nint  = ((offset * offset) * offset);\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}"
}