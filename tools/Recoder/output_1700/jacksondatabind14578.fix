{
          "0": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "1": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "2": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i > 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "3": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i <= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "4": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i == 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "5": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i != 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "6": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i < 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "7": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((ch >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "8": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((pos >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "9": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >= 0)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "10": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((-i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "11": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((dateStr >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "12": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(i){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "13": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(!i){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "14": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >= 2)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "15": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "16": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((!i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "17": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((~i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "18": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((ch < \"null\")){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "19": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(( >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "20": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((ch > \"null\")){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "21": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i && 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "22": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i - 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "23": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) || (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "24": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (ch > \"null\"))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "25": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "26": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i & 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "27": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((++i >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "28": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >> 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "29": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(i.isEmpty()){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "30": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i++ >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "31": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(dateStr){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "32": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i < 0))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "33": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\ndo{\n}while(i)\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "34": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(( >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "35": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i.length >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "36": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(( >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "37": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >= -1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "38": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i || (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "39": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((!i && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "40": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((ch < \"null\") && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "41": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) || (ch > \"null\"))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "42": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (ch < \"null\"))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "43": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\ndo{\n}while(!i)\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "44": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((-ch >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "45": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(!i.isEmpty()){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "46": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && i)){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "47": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((-dateStr >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "48": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "49": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && ((ch < \"null\") || (ch > \"null\")))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "50": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i > pos)){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "51": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i == 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "52": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nif((i == null)){\nreturn null;}        while (--i >= 1) {            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "53": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i != null))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "54": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(( >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "55": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nif((i == null)){\nreturn parseAsISO8601(dateStr, pos);}        while (--i >= 1) {            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "56": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i == pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "57": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i > pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "58": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((i < 0)){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "59": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i != 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "60": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i > 0))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "61": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((i != null) && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "62": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i == null))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "63": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nif((i != null)){\nreturn null;}        while (--i >= 1) {            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "64": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i < pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "65": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((--i >= null)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "66": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile((length >= 1)){            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "67": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(NumberInput.inLongRange(dateStr, false)){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "68": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((i == null) && (--i >= 1))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "69": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i != pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "70": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i == 0))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "71": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((ch < \"null\") || (ch > \"null\"))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "72": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) || (i > pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "73": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) || (i > 0))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "74": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i > ch))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "75": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) && (i == dateStr))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }",
          "76": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\nwhile(((--i >= 1) || (i < pos))){\n\n}            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') break;\n        }\n        if (i < 0) { // all digits\n            if (NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }"
}