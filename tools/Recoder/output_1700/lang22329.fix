{
          "0": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / end.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "1": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "2": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get());\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "3": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (end.get(Calendar.MONTH) / start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "4": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(years));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "5": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "6": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(DAY_OF_MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "7": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(YEAR));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "8": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "9": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) - start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "10": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint years = (end.get(Calendar.MONTH) / start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "11": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "12": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nlong months = (end.get(Calendar.MONTH) / start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "13": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) * start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "14": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(Calendar.DAY_OF_MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "15": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.get(Calendar.YEAR));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "16": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nstart.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "17": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) % start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "18": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) + start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "19": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.formatPeriod(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "20": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) << start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "21": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) >> start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "22": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) & start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "23": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) | start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "24": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) >>> start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "25": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.add(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "26": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (start.get(Calendar.MONTH) * start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "27": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint months = (end.get(Calendar.MONTH) / start.debug(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "28": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (start.get(Calendar.MONTH) / start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "29": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (end.get(Calendar.MONTH) * start.get(Calendar.MONTH));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "30": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nreturn;\n        int months = end.get(Calendar.MONTH) / start.get(Calendar.MONTH);        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "31": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\nint  = (end.get(Calendar.MONTH) * (start.get(Calendar.MONTH) * start.get(Calendar.MONTH)));\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }"
}