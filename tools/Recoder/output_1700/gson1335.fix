{
          "0": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(false){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "1": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "2": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "3": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbeginArray();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "4": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nendArray();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "5": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbeginObject();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "6": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nendObject();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "7": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nconsumeNonExecutePrefix();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "8": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nnextNull();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "9": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nclose();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "10": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nskipValue();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "11": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\ncheckLenient();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "12": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nskipToEndOfLine();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "13": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\ndecodeLiteral();\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "14": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(true){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "15": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(isLenient()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "16": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(hasNext()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "17": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(nextBoolean()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "18": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos += 2;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "19": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos++;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "20": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nbreak;\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "21": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!isLenient()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "22": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!hasNext()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "23": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!nextBoolean()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "24": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif((pos < limit)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "25": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif((pos == limit)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "26": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(-false){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "27": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(pos){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "28": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(-true){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "29": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!pos){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "30": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(fillBuffer()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "31": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\ncheckLenient();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "32": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(fillBuffer(1)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "33": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos += 2;\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "34": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(-1){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "35": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbreak;\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "36": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(buffer){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "37": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!fillBuffer()){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "38": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nreturn false;          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "39": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!fillBuffer(1)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "40": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbeginArray();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "41": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nendArray();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "42": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbeginObject();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "43": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nendObject();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "44": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nconsumeNonExecutePrefix();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "45": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nnextNull();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "46": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nclose();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "47": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nskipValue();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "48": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nskipToEndOfLine();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "49": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\ndecodeLiteral();\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "50": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos++;\nbreak;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "51": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\ncontinue;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "52": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(((pos == limit) && !fillBuffer(1))){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "53": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "54": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!buffer){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "55": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\ncontinue;\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "56": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos += 2;\npos++;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "57": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nreturn;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "58": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\npos += false;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "59": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(2){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "60": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(1){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "61": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nreturn;\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "62": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nreturn c;          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "63": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;          if (!true) {            throw syntaxError(\"Unterminated comment\");\n          }\n\nbreak;\ncontinue;\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "64": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\ncheckLenient();\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "65": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\npos += 2;\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "66": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(!true){            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "67": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(((pos != null) && pos)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }",
          "68": "  private int nextNonWhitespace() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      int c = buffer[pos++];\n      switch (c) {\n      case '\\t':\n      case ' ':\n      case '\\n':\n      case '\\r':\n        continue;\n\n      case '/':\n        if (pos == limit && !fillBuffer(1)) {\n          return c;\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\nif(((pos != null) && !pos)){\n            throw syntaxError(\"Unterminated comment\");\n          }\n          pos += 2;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          continue;\n\n        default:\n          return c;\n        }\n\n      case '#':\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        continue;\n\n      default:\n        return c;\n      }\n    }\n    throw new EOFException(\"End of input\");\n  }"
}