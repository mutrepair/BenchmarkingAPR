{
          "0": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) - delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "1": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) / delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "2": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k - offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "3": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "4": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "5": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal long i = ((k + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "6": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (k + offset);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "7": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) + delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "8": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) >> delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "9": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) % i);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "10": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) % vUp);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "11": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) % d);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "12": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) % k);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "13": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + i) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "14": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) << delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "15": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k % offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "16": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k / offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "17": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + vUp) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "18": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((i + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "19": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) >>> delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "20": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + delta) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "21": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k * offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "22": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k != (delta + d)) && (vUp[(i + 1)] <= vUp[(i - 1)]));\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "23": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + d) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "24": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + k) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "25": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((vUp + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "26": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (vUp[(i + 1)] <= vUp[(i - 1)]);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "27": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (k == (delta - d));\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "28": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k >> offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "29": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) & delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "30": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((delta + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "31": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (k != (delta + d));\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "32": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (delta - d);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "33": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (delta + d);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "34": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((d + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "35": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = (i + 1);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "36": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k + offset) | delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "37": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = sequence1.get(x);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "38": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "39": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nvUp[i] = (vUp[(i + 1)] - 1);\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "40": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nvUp[i] = vUp[(i - 1)];\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "41": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = sequence2.get(y);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "42": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nvUp[i] = x--;\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "43": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = equator.equate(sequence1.get(x), sequence2.get(y));\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "44": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\ny--;\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "45": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nif(((k == (delta - d)) || ((k != (delta + d)) && (vUp[(i + 1)] <= vUp[(i - 1)])))){\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "46": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nreturn buildSnake(vUp[i], ((k + start1) - start2), end1, end2);                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "47": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k >>> offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "48": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k << offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "49": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nint i = ((k + offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "50": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nif(((((delta % 2) == 0) && (-d <= k)) && (k <= d))){\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "51": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nif((vUp[i] <= vDown[(i + delta)])){\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "52": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nint x = (vUp[i] - 1);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "53": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nint y = (((x - start1) + start2) - k);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "54": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k & offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "55": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((k <= offset) % delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "56": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nreturn;\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "57": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nbreak;\n                final int i = (k + offset) % delta;                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "58": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((delta * delta) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "59": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((delta + delta) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "60": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((offset * delta) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "61": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((offset + delta) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "62": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((delta * offset) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "63": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\nfinal int i = ((delta + offset) * delta);\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }"
}