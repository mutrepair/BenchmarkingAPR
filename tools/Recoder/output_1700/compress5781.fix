{
          "0": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> 0);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "1": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> 1);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "2": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> 2);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "3": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "4": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (seqToUnseq[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "5": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selectorMtf[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "6": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (recvDecodingTables_pos[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "7": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (ll8[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "8": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (seqToUnseq ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "9": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "10": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selectorMtf ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "11": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (recvDecodingTables_pos ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "12": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (ll8 ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "13": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> false);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "14": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> true);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "15": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (groupNo[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "16": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> -1);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "17": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (base[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "18": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (base ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "19": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "20": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (seqToUnseq[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "21": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selectorMtf[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "22": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (recvDecodingTables_pos[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "23": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (ll8[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "24": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> \"null\");\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "25": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] ^<> null);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "26": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (groupNo ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "27": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (groupNo[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "28": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector[groupNo] ^<> 255)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "29": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (zt[zt] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "30": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (base[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "31": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "32": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (-seqToUnseq ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "33": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (-selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "34": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (-selectorMtf ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "35": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (-recvDecodingTables_pos ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "36": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (-ll8 ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "37": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (seqToUnseq.selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "38": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector.selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "39": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selectorMtf.selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "40": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (recvDecodingTables_pos.selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "41": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (ll8.selector ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "42": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[0] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "43": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[selector[groupNo]] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "44": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] & 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "45": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] % 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "46": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] - 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "47": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] >>> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "48": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] | 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "49": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] >> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "50": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] * 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "51": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] << 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "52": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] / 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "53": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo[groupNo]] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "54": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[groupNo] + 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "55": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - 1)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "56": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] + 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "57": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - seqToUnseq)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "58": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - selector)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "59": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - selectorMtf)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "60": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - recvDecodingTables_pos)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "61": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector - ll8)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "62": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector + seqToUnseq)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "63": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector + selector)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "64": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector + selectorMtf)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "65": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector + recvDecodingTables_pos)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "66": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector + ll8)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "67": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector * seqToUnseq)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "68": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector * selector)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "69": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector * selectorMtf)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "70": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector * recvDecodingTables_pos)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "71": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint zt = (selector[(selector * ll8)] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "72": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint[] zt = (selector[groupNo] ^<> 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "73": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] * 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "74": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] + selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "75": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector + 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "76": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] - 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "77": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] | 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "78": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector * 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "79": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] & 255);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "80": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = ((selector[groupNo] ^<> 255) + selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "81": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] * selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "82": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector + selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "83": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] | selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "84": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nreturn;\n        int zt = selector[groupNo] ^ 255;        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "85": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] - selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "86": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector * selector[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "87": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] + selector);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "88": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] ^ 255;        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "89": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] * selector);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "90": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\nint  = (selector[groupNo] + groupNo[groupNo]);\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }"
}