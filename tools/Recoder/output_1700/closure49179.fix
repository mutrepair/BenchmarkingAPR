{
          "0": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups >= possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "1": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups <= possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "2": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "3": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((pos > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "4": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((limit > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "5": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((groupIndex > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "6": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((min > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "7": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "8": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups < possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "9": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups == possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "10": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((next > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "11": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((ch > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "12": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups != possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "13": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\n++pos;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "14": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\npossibleGroupIndex = twoDigitGroupIndex;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "15": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((pos.numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "16": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups.numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "17": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((limit.numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "18": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((groupIndex.numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "19": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((min.numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "20": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups().numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "21": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((hashCode().numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "22": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((complexity().numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "23": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((\"null\" <= ch)){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "24": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((\"null\" <= next)){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "25": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((-possibleGroupIndex > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "26": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((ch == \"null\")){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "27": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(numCapturingGroups){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "28": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((ch <= \"null\")){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "29": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nPreconditions.checkState((pattern.charAt(pos) == \"null\"));\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "30": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((next <= \"null\")){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "31": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(possibleGroupIndex){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "32": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (ch <= \"null\"))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "33": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (ch == \"null\"))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "34": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups >= twoDigitGroupIndex)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "35": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex > numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "36": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((!possibleGroupIndex > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "37": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((charGroup != null)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "38": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex * 10)){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "39": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((-numCapturingGroups > possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "40": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((\"null\" <= next) && (next <= \"null\"))){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "41": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((pos < limit)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "42": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups > next)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "43": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (next <= \"null\"))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "44": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((\"null\" <= ch) && (ch <= \"null\"))){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "45": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\npossibleGroupIndex = possibleGroupIndex;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "46": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex <= 7)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "47": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(isCaseSensitive()){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "48": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(containsAnchor()){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "49": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(hasCapturingGroup()){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "50": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((\"null\" <= ch)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "51": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\npossibleGroupIndex++;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "52": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups > ch)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "53": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex > possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "54": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex != \"null\")){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "55": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (ch <= \"null\"))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "56": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && possibleGroupIndex)){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "57": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (possibleGroupIndex > numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "58": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((ch == \"null\") || (ch == \"null\"))){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "59": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex > 0))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "60": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (numCapturingGroups > possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "61": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex >= numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "62": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex < numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "63": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || possibleGroupIndex)){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "64": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn new Text((\"null\" + parseEscapeChar()));          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "65": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups >> possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "66": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "67": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn new WordBoundary(ch);          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "68": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups - possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "69": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn new Charset(charGroup, CharRanges.EMPTY);          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "70": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (possibleGroupIndex > possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "71": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn new BackReference(possibleGroupIndex);          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "72": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups >>> possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "73": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex == null)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "74": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex < possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "75": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex >= possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "76": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((possibleGroupIndex != null)){\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n}\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "77": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nint possibleGroupIndex = (ch - \"null\");\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "78": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (possibleGroupIndex < numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "79": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex <= numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "80": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (possibleGroupIndex > 0))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "81": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (numCapturingGroups > possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "82": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nbreak;\n          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "83": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif((numCapturingGroups || possibleGroupIndex)){            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "84": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (numCapturingGroups < possibleGroupIndex))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "85": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex >= 0))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "86": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (numCapturingGroups > numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "87": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) || (possibleGroupIndex >= numCapturingGroups))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "88": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nreturn new Text(Character.toString(((possibleGroupIndex <= 7))?(char)possibleGroupIndex:ch));          if (numCapturingGroups > possibleGroupIndex) {            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }",
          "89": "      private RegExpTree parseEscape() {\n        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n        ++pos;\n        char ch = pattern.charAt(pos);\n        if (ch == 'b' || ch == 'B') {\n          ++pos;\n          return new WordBoundary(ch);\n        } else if ('1' <= ch && ch <= '9') {\n          ++pos;\n          int possibleGroupIndex = ch - '0';\nif(((numCapturingGroups > possibleGroupIndex) && (possibleGroupIndex < 0))){\n            if (pos < limit) {\n              char next = pattern.charAt(pos);\n              if ('0' <= next && next <= '9') {\n                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n                if (numCapturingGroups >= twoDigitGroupIndex) {\n                  ++pos;\n                  possibleGroupIndex = twoDigitGroupIndex;\n                }\n              }\n            }\n            return new BackReference(possibleGroupIndex);\n          } else {\n            // \\1 - \\7 are octal escapes if there is no such group.\n            // \\8 and \\9 are the literal characters '8' and '9' if there\n            // is no such group.\n            return new Text(Character.toString(\n              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n          }\n        } else {\n          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n          if (charGroup != null) {  // Handle \\d, etc.\n            ++pos;\n            return new Charset(charGroup, CharRanges.EMPTY);\n          }\n          return new Text(\"\" + parseEscapeChar());\n        }\n      }"
}