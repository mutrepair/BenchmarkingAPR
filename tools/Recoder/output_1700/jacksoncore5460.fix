{
          "0": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value >= 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "1": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 1)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "2": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 2)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "3": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value <= 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "4": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value == 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "5": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value > 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "6": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != -1)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "7": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\noffset = outputFullTriplet(value, buffer, offset);\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "8": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nvalue -= (thousands * 1000);\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "9": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "10": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\noffset = outputLeadingTriplet(thousands, buffer, offset);\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "11": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 1000)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "12": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nvalue = -value;\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "13": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "14": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nbuffer[offset++] = \"null\";\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "15": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nbuffer[offset++] = (char)(\"null\" + value);\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "16": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\noffset = outputLeadingTriplet(value, buffer, offset);\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "17": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nreturn offset;                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "18": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nreturn outputLong((long)value, buffer, offset);                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "19": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value != 10))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "20": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value < 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "21": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((thousands * 1000)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "22": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value / 1000))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "23": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value < 0))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "24": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value >= BILLION))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "25": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value >= BILLION)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "26": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (value != 10))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "27": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value == Integer.MIN_VALUE))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "28": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (\"null\" + value))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "29": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (thousands * 1000))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "30": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value - 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "31": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value < 0)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "32": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value < 1000))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "33": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value == Integer.MIN_VALUE)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "34": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 10)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "35": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(value){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "36": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nbreak;\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "37": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((thousands != 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "38": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (value / 1000))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "39": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (value >= BILLION))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "40": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (value < 0))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "41": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != 0)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "42": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value < 1000)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "43": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (\"null\" + value))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "44": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value < MILLION) && (value != 10))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "45": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value < MILLION)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "46": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (thousands * 1000))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "47": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) || (value == Integer.MIN_VALUE))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "48": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value / 1000)){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "49": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value < 1000)){\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n}\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "50": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nreturn false;                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "51": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value + 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "52": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value >> 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "53": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value != false)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "54": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nreturn;\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "55": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif((value >>> 10)){                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "56": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nbreak;\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "57": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\ncontinue;\n                if (value != 10) {                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "58": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value[offset++] != null))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "59": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value[offset++] == 0))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "60": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value[offset++] != 0))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "61": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\nif(((value != 10) && (value[offset++] == null))){\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }"
}