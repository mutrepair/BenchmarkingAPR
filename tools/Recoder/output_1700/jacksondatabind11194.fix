{
          "0": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(true){            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "1": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "2": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn null;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "3": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn result;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "4": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(false){            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "5": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\ntb.writeEndObject();\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "6": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp = tb.asParser(jp);\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "7": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp.nextToken();\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "8": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn;\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "9": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nbreak;\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "10": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(ctxt){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "11": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(result){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "12": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(deser){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "13": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn deser.deserialize(jp, ctxt);        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "14": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(((\"null\" + _typePropertyName) + \"null\")){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "15": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(jp){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "16": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((((\"null\" + _typePropertyName) + \"null\") + baseTypeName())){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "17": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn super.deserializeTypedFromAny(jp, ctxt);        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "18": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp = null;\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "19": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((\"null\" + _typePropertyName)){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "20": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(_baseType){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "21": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(((((\"null\" + _typePropertyName) + \"null\") + baseTypeName()) + \"null\")){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "22": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(((\"null\" + _typePropertyName) + \"null\")){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "23": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn deser;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "24": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((((\"null\" + _typePropertyName) + \"null\") + baseTypeName())){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "25": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn ctxt;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "26": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn jp;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "27": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn this;        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "28": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn \"null\";        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "29": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\nreturn null;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "30": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(!ctxt){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "31": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((\"null\" + _typePropertyName)){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "32": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(((((\"null\" + _typePropertyName) + \"null\") + baseTypeName()) + \"null\")){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "33": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "34": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nbreak;\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "35": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp = result;\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "36": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\ncontinue;\n}\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "37": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\ncontinue;\n        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "38": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif(\"null\"){            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "39": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result == null)){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "40": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result == null)){\nreturn null;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "41": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "42": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((jp != null)){\nreturn null;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "43": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((tb != null)){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "44": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((jp != null)){\nreturn result;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "45": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((deser != null)){\nreturn null;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "46": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((ctxt != null)){\nreturn null;}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "47": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\ntb.writeEndObject();\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "48": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp.nextToken();\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "49": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\njp = tb.asParser(jp);\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "50": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\nreturn \"null\";}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "51": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\ncontinue;\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "52": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nreturn;\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "53": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((ctxt && (ctxt != null))){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "54": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((ctxt && (ctxt == null))){\n            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }",
          "55": "    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n            DeserializationContext ctxt, TokenBuffer tb)\n        throws IOException, JsonProcessingException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                jp = tb.asParser(jp);\n                // must move to point to the first token:\n                jp.nextToken();\n            }\n            return deser.deserialize(jp, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\nif((result != null)){\njp = null;\n}        if (false) {            return super.deserializeTypedFromAny(jp, ctxt);\n        }\n        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    }"
}