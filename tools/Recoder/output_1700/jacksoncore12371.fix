{
          "0": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn parseMediumFieldName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "1": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "2": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "3": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 0);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "4": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 0xFF);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "5": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "6": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn parseEscapedFieldName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "7": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, -1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "8": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, true);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "9": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "10": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(sInputCodesUtf8, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "11": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(sInputCodesLatin1, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "12": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quad1, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "13": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, false);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "14": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "15": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, \"null\");                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "16": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "17": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "18": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName();                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "19": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "20": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, i, 2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "21": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, i, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "22": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, _inputBuffer, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "23": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\ni = (_inputBuffer[_inputPtr++] & 0xFF);\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "24": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_closeInput();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "25": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_releaseBuffers();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "26": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nclose();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "27": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_isNextTokenNameYes();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "28": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_finishString();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "29": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipString();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "30": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipComment();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "31": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipCComment();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "32": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipCppComment();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "33": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipCR();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "34": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n_skipLF();\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "35": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "36": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, i, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "37": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, _inputBuffer, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "38": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, qlen, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "39": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, _inputPtr, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "40": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(i, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "41": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_inputBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "42": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "43": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, _quadBuffer, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "44": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn parseLongFieldName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "45": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, _inputPtr, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "46": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, null);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "47": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn i;                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "48": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_inputPtr, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "49": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn qlen;                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "50": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn debug(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "51": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nq = ((q << 8) | i);\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "52": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\ncontinue;\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "53": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn e(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "54": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nbreak;\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "55": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn;\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "56": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\ncontinue;\n                    return findName(_quadBuffer, qlen, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "57": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "58": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "59": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "60": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "61": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "62": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "63": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "64": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "65": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "66": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "67": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "68": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "69": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "70": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "71": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "72": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "73": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, q, q, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "74": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, q, q, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "75": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, q, q, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "76": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, q, q, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "77": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "78": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "79": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "80": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "81": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "82": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "83": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "84": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "85": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "86": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, qlen, sInputCodesUtf8);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "87": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, qlen, sInputCodesLatin1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "88": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, qlen, _quadBuffer);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "89": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, qlen, _quad1);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "90": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "91": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, sInputCodesUtf8, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "92": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, sInputCodesLatin1, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "93": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, _quadBuffer, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "94": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, _quad1, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "95": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "96": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, q, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "97": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "98": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, i, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "99": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "100": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(q, q, i, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "101": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, i, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "102": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(_quadBuffer, q, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "103": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, i, q, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "104": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, qlen, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "105": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, q, -2);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "106": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, q, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "107": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, q, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "108": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, i, i);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }",
          "109": "    protected Name parseLongFieldName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = sInputCodesLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\nreturn findName(qlen, q, q, i, q);                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }"
}