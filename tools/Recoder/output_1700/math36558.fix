{
          "0": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "1": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "2": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[3] = (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "3": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (ort[2].[0] - ort[0].[2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "4": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (ort[2].[0] - ort[0].[2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "5": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[3] = (inv * (ort[2].[1] + ort[1].[2]));\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "6": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] += (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "7": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((ort[2].[0] - ort[0].[2])){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "8": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] += (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "9": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (inv * (ort[0].[1] + ort[1].[0]));\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "10": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[2] = (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "11": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[3] = (inv * (ort[2].[1] + ort[1].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "12": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nreturn;\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "13": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[2] = (0.5 * FastMath.sqrt((s + 1.0)));\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "14": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "15": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv != null)){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "16": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[3] = (ort[2].[0] - ort[0].[2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "17": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (ort[0].[1] + ort[1].[0]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "18": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (ort[2].[1] + ort[1].[2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "19": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[2] = (0.5 * FastMath.sqrt((s + 1.0)));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "20": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (0.5 * FastMath.sqrt((s + 1.0)));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "21": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (ort[0].[1] + ort[1].[0]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "22": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((ort[2].[1] + ort[1].[2])){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "23": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (ort[2].[1] + ort[1].[2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "24": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv * (ort[2].[0] - ort[0].[2]))){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "25": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[3] += (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "26": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] -= (inv * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "27": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (s + 1.0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "28": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[0].[1] + ort[1].[0]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "29": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (inv * (ort[2].[1] + ort[1].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "30": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[3] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "31": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (s > -0.19);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "32": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "33": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((ort[0].[1] + ort[1].[0])){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "34": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[3] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "35": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[1] = (inv * (ort[0].[1] + ort[1].[0]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "36": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((0.5 * FastMath.sqrt((s + 1.0)))){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "37": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[0].[2] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "38": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "39": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "40": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[2].[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "41": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "42": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[0].[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "43": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[1].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "44": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[0] - ort[3]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "45": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[0] - ort[1]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "46": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[1].[2] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "47": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[0].[2] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "48": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[1].[2] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "49": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (quat[1] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "50": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv == 0)){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "51": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[0] - inv[3]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "52": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (quat[3] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "53": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (ort[2].[0] - ort[2].[0]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "54": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (inv * (inv[1].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "55": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv > 0)){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "56": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv == null)){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "57": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nbreak;\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "58": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nif((inv != 0)){\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n}\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "59": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((inv * (ort[2].[0] - ort[0].[2])) * 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "60": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((inv * (ort[2].[0] - ort[0].[2])) + 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "61": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((inv * (ort[2].[0] - ort[0].[2])) + 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "62": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((inv * (ort[2].[0] - ort[0].[2])) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "63": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\ndouble inv = (0.25 / quat[2]);\n                  quat[-1] = inv * (ort[2][0] - ort[0][2]);                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "64": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * 1) * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "65": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * 1) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "66": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * 0) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "67": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * 1)) * ort) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "68": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "69": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 0) * 0) * 0) * ort[2].[0]) + 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "70": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 0) * 0) * 0) * ort[2].[0]) + ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "71": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * 1)) * ort[2].[0]) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "72": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 0) * 0) * 0) * ort[0].[2]) + ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "73": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 1) * 0) * 0) * ort[2].[0]) + ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "74": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 1) * 1) * 1) * ort[2].[0]) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "75": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * 1)) * ort[0].[2]) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "76": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 1) * 1) * 0) * ort[2].[0]) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "77": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0]) * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "78": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0]) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "79": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0]) * 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "80": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0]) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "81": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * inv[0]) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "82": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[1]) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "83": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 1) * 1) * (ort * ort)) * ort) * ort);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "84": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = (((((ort * 1) * 1) * (ort * ort)) * ort) * 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "85": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].size()) * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "86": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].length()) * (ort[2].[0] - ort[0].[2]));\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "87": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].size()) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "88": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].length()) * 0);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "89": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].length()) * 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }",
          "90": "  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\nquat[-1] = ((((ort * 1) * (ort * ort)) * ort[0].size()) * 1);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }"
}