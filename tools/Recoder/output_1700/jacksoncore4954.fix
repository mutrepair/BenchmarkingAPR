{
          "0": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "1": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (digitChars[offset] - \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "2": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = (++offset < len);\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "3": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = (digitChars[offset] - \"null\");\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "4": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = (digitChars[offset] * \"null\");\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "5": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (digitChars[offset] - \"null\"));\n                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "6": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (offset[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "7": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = (num * 10);\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "8": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (digitChars[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "9": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nif((++offset < len)){\n                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n}\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "10": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (num[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "11": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 10) + (len[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "12": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 0) + (digitChars[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "13": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nbreak;\n                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "14": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nreturn num;                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "15": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = (((num * 10) + (digitChars[offset] - \"null\")) + (digitChars[offset] - \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "16": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nif((++offset < len)){\nnum = ((num * 10) + (digitChars[offset] - \"null\"));\n}                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "17": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nreturn;\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "18": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nnum = ((num * 1) + (digitChars[offset] * \"null\"));\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "19": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\nreturn;\n                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }",
          "20": "    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\ncontinue;\n                            num = (num * 10) + (digitChars[offset] * '0');                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }"
}