{
          "0": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((rawArgs[i] != null) && rawArgs[i].getClass().isArray())){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "1": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((i == (rawArgs.length * 1))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "2": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "3": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "4": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((rawArgs[i] != null)){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "5": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "6": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i >= (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "7": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) || (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "8": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i > (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "9": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "10": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] >= null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "11": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i].getClass().isArray() != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "12": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] > null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "13": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 0)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "14": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] == null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "15": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i]) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "16": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1))))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "17": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] <= null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "18": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((rawArgs.length * 1)){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "19": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i < (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "20": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getMatchers().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "21": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "22": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && ((rawArgs[i] != null) && rawArgs[i].getClass().isArray())) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "23": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "24": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getRawArguments().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "25": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i <= (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "26": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((i != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "27": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((matchers[i].getClass().isArray() != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "28": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isVarArgs()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "29": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && ((i == (rawArgs.length * 1)) || (i == (rawArgs.length * 1))))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "30": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] < null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "31": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].isVarArgs().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "32": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (i * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "33": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 2)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "34": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && matchers[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "35": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().getMatchers()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "36": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((matchers != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "37": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().getRawArguments()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "38": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && ((rawArgs[i] != null) && rawArgs[i].getClass().isArray()))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "39": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(isArray()){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "40": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].isArray().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "41": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i].getClass() != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "42": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && invocationMatcher[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "43": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i].isArray() != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "44": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((rawArgs[i] != null) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "45": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && i) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "46": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().getClass()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "47": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (matchers * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "48": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(getClass()){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "49": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && matchers) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "50": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i != (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "51": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs[i].getClass().isArray() * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "52": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((rawArgs[i] != null) && rawArgs[i].getClass().isArray())){\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length * 1) {                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n}\n        }\n\n        return true;\n    }",
          "53": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getMethod().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "54": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == null)) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "55": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().getMethod()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "56": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getName().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "57": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1))) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "58": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((matchers[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "59": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((invocationMatcher[i].getClass().isArray() != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "60": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].size().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "61": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && m) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "62": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (matchers[i].getClass().isArray() * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "63": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((m != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "64": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((i == (rawArgs.length * 1))){\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length * 1) {                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n}\n        }\n\n        return true;\n    }",
          "65": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && matchers[i]) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "66": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == 1)) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "67": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs[i] * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "68": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif(((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i != null)) && (i == (rawArgs.length * 1)))){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "69": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nactualMatcher = (MatcherDecorator)m;\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length * 1) {                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "70": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "71": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs != null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "72": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((m instanceof MatcherDecorator)){\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "73": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().size()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "74": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nactualMatcher = m;\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length * 1) {                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "75": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().getName()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "76": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].varArgsMatch().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "77": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().varArgsMatch()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "78": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i && (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "79": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] != null) && rawArgs[i].getClass().isArray()) && (i || (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "80": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nif((((rawArgs[i] && null) && rawArgs[i].getClass().isArray()) && (i == (rawArgs.length * 1)))){                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
          "81": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\nreturn;\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length * 1) {                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }"
}