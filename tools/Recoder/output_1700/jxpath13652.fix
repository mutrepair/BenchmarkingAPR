{
          "0": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "1": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicateName(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "2": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicateIndex(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "3": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "4": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, 0);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "5": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\n        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "6": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, false);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "7": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, true);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "8": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, 2);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "9": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, null);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "10": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, axis, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "11": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, axis, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "12": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, axis, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "13": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, e, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "14": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(axis, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "15": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(currentStep);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "16": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, axis, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "17": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicate, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "18": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(steps);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "19": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "20": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, e, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "21": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, debug, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "22": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "23": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, e, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "24": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(e, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "25": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate();        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "26": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, predicate, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "27": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, predicates, \"null\");        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "28": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(parent);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "29": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, predicate, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "30": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doStepPredicatesStandard(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "31": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, debug, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "32": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, e, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "33": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicate, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "34": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, i, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "35": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, debug, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "36": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(debug, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "37": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, predicate, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "38": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, steps, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "39": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, AXIS_SELF, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "40": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, currentStep, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "41": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, currentStep, context, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "42": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, i, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "43": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, debug, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "44": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, steps, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "45": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, i, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "46": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(i, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "47": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, AXIS_SELF, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "48": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, steps, , predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "49": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(steps, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "50": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, currentStep, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "51": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, , currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "52": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, parent, context, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "53": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn getAxis(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "54": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(currentStep, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "55": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "56": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, steps, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "57": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, i, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "58": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, currentStep, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "59": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, context, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "60": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(context, , steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "61": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn debug(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "62": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn (context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "63": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn e(context, parent, steps, currentStep, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "64": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "65": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn;\n            return doPredicate(\n                context,\n                parent,\n                steps,\n                currentStep,\n                predicates,\n                1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "66": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "67": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(currentStep, predicates, predicates, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "68": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, currentStep);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "69": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, 0);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "70": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, currentStep, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "71": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "72": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nbreak;\n            return doPredicate(\n                context,\n                parent,\n                steps,\n                currentStep,\n                predicates,\n                1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "73": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\n            return doPredicate(\n                context,\n                parent,\n                steps,\n                currentStep,\n                predicates,\n                1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "74": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, predicates, 1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "75": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, 1, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "76": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(currentStep, predicates, predicates, predicates, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "77": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, predicates, 0);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "78": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, currentStep, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "79": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, predicates, predicates, currentStep);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "80": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\ncontinue;\n            return doPredicate(\n                context,\n                parent,\n                steps,\n                currentStep,\n                predicates,\n                1);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "81": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, predicates, currentStep, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "82": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, predicates, currentStep, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }",
          "83": "    private static NodePointer doStepPredicatesStandard(\n            EvalContext context, NodePointer parent,\n            Step[] steps, int currentStep)\n    {\n        Step step = steps[currentStep];\n        Expression predicates[] = step.getPredicates();\n\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_SELF) {\nreturn doPredicate(predicates, predicates, predicates, currentStep, predicates, predicates, predicates, predicates);        }\n\n        Expression predicate = predicates[0];\n\n        // Optimize for a single predicate to avoid building a list\n        // and to allow the direct access to the index'th element\n        // in the case of a simple subscript predecate\n        // It is a very common use case, so it deserves individual\n        // attention\n        if (predicates.length == 1) {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            NodePointer pointer = null;\n            if (it != null) {\n                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                    String key = keyFromPredicate(context, predicate);\n                    for (int i = 1; it.setPosition(i); i++) {\n                        NodePointer ptr = it.getNodePointer();\n                        if (isNameAttributeEqual(ptr, key)) {\n                            pointer = ptr;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    int index = indexFromPredicate(context, predicate);\n                    if (it.setPosition(index + 1)) {\n                        pointer = it.getNodePointer();\n                    }\n                }\n            }\n            if (pointer != null) {\n                return doStep(context, pointer, steps, currentStep + 1);\n            }\n        }\n        else {\n            NodeIterator it = getNodeIterator(context, parent, step);\n            if (it != null) {\n                List list = new ArrayList();\n                for (int i = 1; it.setPosition(i); i++) {\n                    list.add(it.getNodePointer());\n                }\n                NodePointer pointer =\n                    doPredicatesStandard(\n                        context,\n                        list,\n                        steps,\n                        currentStep,\n                        predicates,\n                        0);\n                if (pointer != null) {\n                    return pointer;\n                }\n            }\n        }\n        return createNullPointer(context, parent, steps, currentStep);\n    }"
}