{
          "0": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k <= (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "1": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k >= (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "2": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "3": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k > (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "4": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "5": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k || (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "6": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k == (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "7": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;( < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "8": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((k < (sequence.length * 1)))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "9": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(y1Diag < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "10": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));y1Diag) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "11": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "12": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k - (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "13": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k && (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "14": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 0));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "15": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;( < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "16": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(sequence.length * 1);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "17": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(long k = 0;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "18": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((k < (sequence.length * 1)))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "19": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(diagonal < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "20": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k != (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "21": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;( < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "22": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));diagonal) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "23": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length <= 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "24": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 1;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "25": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((k < (sequence.length * 1)))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "26": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));-k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "27": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;( < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "28": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(-k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "29": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length >= 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "30": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k + (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "31": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < ( * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "32": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((k < (sequence.length * 1)))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "33": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < 0);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "34": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k < (sequence.length * 1)));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "35": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 2));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "36": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 2;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "37": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (y1Diag * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "38": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;;++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "39": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < ( * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "40": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(diagonal < k);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "41": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (-k * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "42": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "43": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < 1);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "44": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < k);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "45": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(sequence.length - 1);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "46": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((sequence.length * 1))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "47": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < diagonal);++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "48": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < ( * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "49": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = -1;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "50": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(double[] k = 0;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "51": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * -1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "52": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n(;;)      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "53": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\n((k < (sequence.length * 1)))      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "54": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length > 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "55": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k++ < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "56": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < ( * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "57": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));k++) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "58": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k-- < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "59": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length * 1));k--) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "60": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (sequence.length < 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "61": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(double[] k = 0;(k < (sequence.length * 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "62": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "63": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - 0));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "64": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal - k));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "65": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;((k < (sequence.length * 1)) || (k < k));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "66": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal - 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "67": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;((k < (sequence.length * 1)) || (k < 0));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "68": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - k));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "69": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - 2));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "70": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal - 0));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "71": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;((k < (sequence.length * 1)) || (k < 1));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "72": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nreturn;\n    for (int k = 0; k < sequence.length * 1; ++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "73": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - diagonal));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "74": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal - diagonal));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "75": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(diagonal < (k - k));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "76": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (k - sequence.length));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
          "77": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final double[] yDot0   = new double[y.length];\n    final double[] y1      = new double[y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yTmpDot = new double[y.length];\n\n    final double[][] diagonal = new double[sequence.length-1][];\n    final double[][] y1Diag = new double[sequence.length-1][];\nfor(int k = 0;(k < (diagonal - sequence.length));++k) {      diagonal[k] = new double[y.length];\n      y1Diag[k] = new double[y.length];\n    }\n\n    final double[][][] fk  = new double[sequence.length][][];\n    for (int k = 0; k < sequence.length; ++k) {\n\n      fk[k]    = new double[sequence[k] + 1][];\n\n      // all substeps start at the same point, so share the first array\n      fk[k][0] = yDot0;\n\n      for (int l = 0; l < sequence[k]; ++l) {\n        fk[k][l+1] = new double[y0.length];\n      }\n\n    }\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n\n    final double[] yDot1 = new double[y0.length];\n    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];\n\n    // initial scaling\n    final double[] scale = new double[mainSetDimension];\n    rescale(y, y, scale);\n\n    // initial order selection\n    final double tol =\n        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));\n    int targetIter = FastMath.max(1,\n                              FastMath.min(sequence.length - 2,\n                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n\n    // set up an interpolator sharing the integrator arrays\n    final AbstractStepInterpolator interpolator =\n            new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                   y1, yDot1,\n                                                   yMidDots, forward,\n                                                   equations.getPrimaryMapper(),\n                                                   equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    stepStart = equations.getTime();\n    double  hNew             = 0;\n    double  maxError         = Double.MAX_VALUE;\n    boolean previousRejected = false;\n    boolean firstTime        = true;\n    boolean newStep          = true;\n    boolean firstStepAlreadyComputed = false;\n    initIntegration(equations.getTime(), y0, t);\n    costPerTimeUnit[0] = 0;\n    isLastStep = false;\n    do {\n\n      double error;\n      boolean reject = false;\n\n      if (newStep) {\n\n        interpolator.shift();\n\n        // first evaluation, at the beginning of the step\n        if (! firstStepAlreadyComputed) {\n          computeDerivatives(stepStart, y, yDot0);\n        }\n\n        if (firstTime) {\n          hNew = initializeStep(forward, 2 * targetIter + 1, scale,\n                                stepStart, y, yDot0, yTmp, yTmpDot);\n        }\n\n        newStep = false;\n\n      }\n\n      stepSize = hNew;\n\n      // step adjustment near bounds\n      if ((forward && (stepStart + stepSize > t)) ||\n          ((! forward) && (stepStart + stepSize < t))) {\n        stepSize = t - stepStart;\n      }\n      final double nextT = stepStart + stepSize;\n      isLastStep = forward ? (nextT >= t) : (nextT <= t);\n\n      // iterate over several substep sizes\n      int k = -1;\n      for (boolean loop = true; loop; ) {\n\n        ++k;\n\n        // modified midpoint integration with the current substep\n        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n                       (k == 0) ? y1 : y1Diag[k-1],\n                       yTmp)) {\n\n          // the stability check failed, we reduce the global step\n          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n          reject = true;\n          loop   = false;\n\n        } else {\n\n          // the substep was computed successfully\n          if (k > 0) {\n\n            // extrapolate the state at the end of the step\n            // using last iteration data\n            extrapolate(0, k, y1Diag, y1);\n            rescale(y, y1, scale);\n\n            // estimate the error at the end of the step.\n            error = 0;\n            for (int j = 0; j < mainSetDimension; ++j) {\n              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n              error += e * e;\n            }\n            error = FastMath.sqrt(error / mainSetDimension);\n\n            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n              // error is too big, we reduce the global step\n              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n              reject = true;\n              loop   = false;\n            } else {\n\n              maxError = FastMath.max(4 * error, 1.0);\n\n              // compute optimal stepsize for this order\n              final double exp = 1.0 / (2 * k + 1);\n              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n              final double pow = FastMath.pow(stepControl3, exp);\n              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n\n              // check convergence\n              switch (k - targetIter) {\n\n              case -1 :\n                if ((targetIter > 1) && ! previousRejected) {\n\n                  // check if we can stop iterations now\n                  if (error <= 1.0) {\n                    // convergence have been reached just before targetIter\n                    loop = false;\n                  } else {\n                    // estimate if there is a chance convergence will\n                    // be reached on next iteration, using the\n                    // asymptotic evolution of error\n                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /\n                                         (sequence[0] * sequence[0]);\n                    if (error > ratio * ratio) {\n                      // we don't expect to converge on next iteration\n                      // we reject the step immediately and reduce order\n                      reject = true;\n                      loop   = false;\n                      targetIter = k;\n                      if ((targetIter > 1) &&\n                          (costPerTimeUnit[targetIter-1] <\n                           orderControl1 * costPerTimeUnit[targetIter])) {\n                        --targetIter;\n                      }\n                      hNew = optimalStep[targetIter];\n                    }\n                  }\n                }\n                break;\n\n              case 0:\n                if (error <= 1.0) {\n                  // convergence has been reached exactly at targetIter\n                  loop = false;\n                } else {\n                  // estimate if there is a chance convergence will\n                  // be reached on next iteration, using the\n                  // asymptotic evolution of error\n                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n                  if (error > ratio * ratio) {\n                    // we don't expect to converge on next iteration\n                    // we reject the step immediately\n                    reject = true;\n                    loop = false;\n                    if ((targetIter > 1) &&\n                        (costPerTimeUnit[targetIter-1] <\n                         orderControl1 * costPerTimeUnit[targetIter])) {\n                      --targetIter;\n                    }\n                    hNew = optimalStep[targetIter];\n                  }\n                }\n                break;\n\n              case 1 :\n                if (error > 1.0) {\n                  reject = true;\n                  if ((targetIter > 1) &&\n                      (costPerTimeUnit[targetIter-1] <\n                       orderControl1 * costPerTimeUnit[targetIter])) {\n                    --targetIter;\n                  }\n                  hNew = optimalStep[targetIter];\n                }\n                loop = false;\n                break;\n\n              default :\n                if ((firstTime || isLastStep) && (error <= 1.0)) {\n                  loop = false;\n                }\n                break;\n\n              }\n\n            }\n          }\n        }\n      }\n\n      if (! reject) {\n          // derivatives at end of step\n          computeDerivatives(stepStart + stepSize, y1, yDot1);\n      }\n\n      // dense output handling\n      double hInt = getMaxStep();\n      if (! reject) {\n\n        // extrapolate state at middle point of the step\n        for (int j = 1; j <= k; ++j) {\n          extrapolate(0, j, diagonal, yMidDots[0]);\n        }\n\n        final int mu = 2 * k - mudif + 3;\n\n        for (int l = 0; l < mu; ++l) {\n\n          // derivative at middle point of the step\n          final int l2 = l / 2;\n          double factor = FastMath.pow(0.5 * sequence[l2], l);\n          int middleIndex = fk[l2].length / 2;\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n          }\n          for (int j = 1; j <= k - l2; ++j) {\n            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n            middleIndex = fk[l2+j].length / 2;\n            for (int i = 0; i < y0.length; ++i) {\n              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n            }\n            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n          }\n          for (int i = 0; i < y0.length; ++i) {\n            yMidDots[l+1][i] *= stepSize;\n          }\n\n          // compute centered differences to evaluate next derivatives\n          for (int j = (l + 1) / 2; j <= k; ++j) {\n            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n              for (int i = 0; i < y0.length; ++i) {\n                fk[j][m][i] -= fk[j][m-2][i];\n              }\n            }\n          }\n\n        }\n\n        if (mu >= 0) {\n\n          // estimate the dense output coefficients\n          final GraggBulirschStoerStepInterpolator gbsInterpolator\n            = (GraggBulirschStoerStepInterpolator) interpolator;\n          gbsInterpolator.computeCoefficients(mu, stepSize);\n\n          if (useInterpolationError) {\n            // use the interpolation error to limit stepsize\n            final double interpError = gbsInterpolator.estimateError(scale);\n            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                0.01));\n            if (interpError > 10.0) {\n              hNew = hInt;\n              reject = true;\n            }\n          }\n\n        }\n\n      }\n\n      if (! reject) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        stepStart = acceptStep(interpolator, y1, yDot1, t);\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n        System.arraycopy(y1, 0, y, 0, y0.length);\n        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n        firstStepAlreadyComputed = true;\n\n        int optimalIter;\n        if (k == 1) {\n          optimalIter = 2;\n          if (previousRejected) {\n            optimalIter = 1;\n          }\n        } else if (k <= targetIter) {\n          optimalIter = k;\n          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n            optimalIter = k-1;\n          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n            optimalIter = FastMath.min(k+1, sequence.length - 2);\n          }\n        } else {\n          optimalIter = k - 1;\n          if ((k > 2) &&\n              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n            optimalIter = k - 2;\n          }\n          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n            optimalIter = FastMath.min(k, sequence.length - 2);\n          }\n        }\n\n        if (previousRejected) {\n          // after a rejected step neither order nor stepsize\n          // should increase\n          targetIter = FastMath.min(optimalIter, k);\n          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n        } else {\n          // stepsize control\n          if (optimalIter <= k) {\n            hNew = optimalStep[optimalIter];\n          } else {\n            if ((k < targetIter) &&\n                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n                               forward, false);\n            } else {\n              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n                                forward, false);\n            }\n          }\n\n          targetIter = optimalIter;\n\n        }\n\n        newStep = true;\n\n      }\n\n      hNew = FastMath.min(hNew, hInt);\n      if (! forward) {\n        hNew = -hNew;\n      }\n\n      firstTime = false;\n\n      if (reject) {\n        isLastStep = false;\n        previousRejected = true;\n      } else {\n        previousRejected = false;\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }"
}