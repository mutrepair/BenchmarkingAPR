{
          "0": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong > CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "1": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong <= CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "2": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong >= CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "3": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong == CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "4": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong < CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "5": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "6": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % BASELENGTH));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "7": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % LOOKUPLENGTH));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "8": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % EIGHTBIT));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "9": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % SIXTEENBIT));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "10": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % TWENTYFOURBITGROUP));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "11": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % FOURBYTE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "12": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % SIGN));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "13": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong - CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "14": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong & CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "15": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong != CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "16": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong + CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "17": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong >> CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "18": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % encodedDataLengthLong));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "19": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % isChunked));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "20": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % tripletCount));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "21": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "22": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % chunckCount));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "23": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "24": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "25": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % MAX_VALUE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "26": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((long)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "27": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += ((float)encodedDataLengthLong % CHUNK_SIZE);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "28": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(long)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "29": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "30": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += (int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "31": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nMath.ceil(((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "32": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.debug(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "33": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nMath.ceil(Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "34": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += (chunckCount * CHUNK_SEPARATOR.length);\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "35": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = ((float)encodedDataLengthLong % CHUNK_SIZE);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "36": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = (tripletCount * 4);\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "37": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nreturn;\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "38": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = ((tripletCount + 1) * 4);\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "39": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "40": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.BASELENGTH));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "41": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.LOOKUPLENGTH));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "42": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.EIGHTBIT));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "43": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.SIXTEENBIT));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "44": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.TWENTYFOURBITGROUP));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "45": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.FOURBYTE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "46": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % Integer.SIGN));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "47": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = ((tripletCount + 1) * 4);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "48": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = (tripletCount * 4);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "49": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += (chunckCount * CHUNK_SEPARATOR.length);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "50": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "51": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "52": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = (float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "53": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.MAX_VALUE(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "54": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil((int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "55": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length >= 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "56": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length <= 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "57": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "58": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % BASELENGTH.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "59": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % LOOKUPLENGTH.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "60": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % EIGHTBIT.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "61": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % SIXTEENBIT.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "62": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % TWENTYFOURBITGROUP.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "63": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % FOURBYTE.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "64": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % SIGN.length));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "65": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = (int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "66": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(CHUNK_SIZE);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "67": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((int)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "68": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nif(isChunked){\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n}\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "69": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nif((encodedDataLengthLong > Integer.MAX_VALUE)){\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n}\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "70": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nif((fewerThan24bits != 0)){\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n}\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "71": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "72": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.encodeBase64(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "73": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.add(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "74": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = (float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "75": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length > 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "76": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.e(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "77": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = (int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "78": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length - 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "79": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:(int)Math.put(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "80": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(chunckCount);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "81": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = Math.ceil(encodedDataLengthLong);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "82": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += Math.ceil(((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "83": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "84": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length < 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "85": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length != 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "86": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += (float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "87": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += (int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "88": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong += (float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "89": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += Math.ceil(CHUNK_SIZE);\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "90": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?0:Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "91": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(CHUNK_SIZE):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "92": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float)encodedDataLengthLong % CHUNK_SIZE));            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "93": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE))):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "94": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += ((CHUNK_SEPARATOR.length == 0))?Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "95": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "96": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(((CHUNK_SEPARATOR.length == 0))?0:(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE))):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "97": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(chunckCount):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "98": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?Math.ceil(encodedDataLengthLong):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "99": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += ((CHUNK_SEPARATOR.length == 0))?0:Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "100": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += ((CHUNK_SEPARATOR.length == 0))?Math.ceil(CHUNK_SIZE):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "101": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nencodedDataLengthLong -= (float)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "102": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount = ((CHUNK_SEPARATOR.length == 0))?(IllegalArgumentException)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE)):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "103": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += ((CHUNK_SEPARATOR.length == 0))?Math.ceil(chunckCount):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "104": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\nchunckCount += ((CHUNK_SEPARATOR.length == 0))?Math.ceil(encodedDataLengthLong):(int)Math.ceil(((float)encodedDataLengthLong % CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }"
}