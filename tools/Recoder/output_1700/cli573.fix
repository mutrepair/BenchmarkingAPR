{
          "0": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "1": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = ;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "2": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = 1;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "3": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = 2;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "4": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = -1;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "5": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "6": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nlong x = -1;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "7": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = null;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "8": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nfinal int x = -1;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "9": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = -2;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "10": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "11": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(dpad);\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "12": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((optBuf.length() < max)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "13": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(createPadding((max - optBuf.length())));\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "14": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noption = (Option)i.next();\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "15": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "16": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nreturn;\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "17": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(option.getDescription());\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "18": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((option.getDescription() != null)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "19": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nreturn sb;        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "20": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = option;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "21": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nsuper.renderOptions();\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "22": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint ;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "23": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = width;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "24": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nsb.append(defaultNewLine);\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "25": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = max;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "26": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = false;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "27": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = -0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "28": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = sb;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "29": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noption = 0;\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "30": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = optBuf.length();\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "31": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif(i.hasNext()){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "32": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((option != null)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "33": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = optBuf;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "34": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf = 0;\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "35": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = };\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "36": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nx = -1;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "37": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((max != null)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "38": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint nextLineTabStop = (max + descPad);\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "39": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = \"null\";\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "40": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((optBuf != null)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "41": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nif((width != null)){\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n}\n    }",
          "42": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nbreak;\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "43": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint x = true;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "44": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n(i.hasNext())        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "45": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(createPadding((max - optBuf.length())));\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "46": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(option.getDescription());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "47": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "48": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nsb.append(defaultNewLine);\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "49": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\nint nextLineTabStop = (max + descPad);\n        int x = -1;\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "50": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf.append(dpad);\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "51": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "52": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\noption = (Option)i.next();\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }"
}