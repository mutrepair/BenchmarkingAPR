{
          "0": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() >= 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "1": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() <= 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "2": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "3": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() == 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "4": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((v2.getZ().getReal() > 0.9999999999)){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "5": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() != 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "6": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > true))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "7": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > false))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "8": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() < 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "9": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > 0.9999999999))){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "10": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((true || (v2.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "11": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif(((false || (v2.getZ().getReal() > 0.9999999999)) || (v2.getZ().getReal() > 0.9999999999))){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "12": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nif((v2 != null)){\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n}\n        }\n\n    }",
          "13": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif(v2.getZ().getReal()){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "14": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > 1))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "15": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nif((v2.getZ().getReal() > 0.9999999999)){\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n}\n        }\n\n    }",
          "16": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().asin() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "17": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getY() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "18": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getZ() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "19": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getX() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "20": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (false || (v2.getZ().getReal() > 0.9999999999)))){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "21": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > 0))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "22": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nif((v2 == null)){\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n}\n        }\n\n    }",
          "23": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif(((false || (v2.getZ().getReal() > 0.9999999999)) && (v2.getZ().getReal() > 0.9999999999))){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "24": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > \"null\"))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "25": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getX().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "26": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getY().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "27": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false && (v2.getZ().getReal() > 0.9999999999))){\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "28": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() >>> 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "29": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() >> 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "30": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nreturn;\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "31": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > 2))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "32": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.asin().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "33": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() & 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "34": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() > null))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "35": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v2.getZ().getReal() || 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "36": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nreturn buildArray(v1.getY().negate().atan2(v1.getZ()), v2.getZ().asin(), v2.getY().negate().atan2(v2.getX()));            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "37": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "38": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (v1.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "39": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "40": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\nif((false || (.getZ().getReal() > 0.9999999999))){                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }",
          "41": "    public T[] getAngles(final RotationOrder order)\n        throws CardanEulerSingularityException {\n\n        if (order == RotationOrder.XYZ) {\n\n            // r (+K) coordinates are :\n            //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n            // (-r) (+I) coordinates are :\n            // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n            final // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));            if  ((false) || (v2.getZ().getReal() > 0.9999999999)) {                throw new CardanEulerSingularityException(true);\n            }\n\nbreak;\n            return buildArray(v1.getY().negate().atan2(v1.getZ()),\n                              v2.getZ().asin(),\n                              v2.getY().negate().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.XZY) {\n\n            // r (+J) coordinates are :\n            // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n            // (-r) (+I) coordinates are :\n            // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getY().asin().negate(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.YXZ) {\n\n            // r (+K) coordinates are :\n            //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getZ().asin().negate(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.YZX) {\n\n            // r (+I) coordinates are :\n            // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n            // (-r) (+J) coordinates are :\n            // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n            // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getZ().negate().atan2(v1.getX()),\n                              v2.getX().asin(),\n                              v2.getZ().negate().atan2(v2.getY()));\n\n        } else if (order == RotationOrder.ZXY) {\n\n            // r (+J) coordinates are :\n            // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n            // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getX().negate().atan2(v1.getY()),\n                              v2.getY().asin(),\n                              v2.getX().negate().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.ZYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n            // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(true);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getX().asin().negate(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XYX) {\n\n            // r (+I) coordinates are :\n            //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n            // (-r) (+I) coordinates are :\n            // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getZ().negate()),\n                              v2.getX().acos(),\n                              v2.getY().atan2(v2.getZ()));\n\n        } else if (order == RotationOrder.XZX) {\n\n            // r (+I) coordinates are :\n            //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n            // (-r) (+I) coordinates are :\n            // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(1, 0, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(1, 0, 0));\n            if ((v2.getX().getReal() < -0.9999999999) || (v2.getX().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getY()),\n                              v2.getX().acos(),\n                              v2.getZ().atan2(v2.getY().negate()));\n\n        } else if (order == RotationOrder.YXY) {\n\n            // r (+J) coordinates are :\n            //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n            // (-r) (+J) coordinates are :\n            // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getZ()),\n                              v2.getY().acos(),\n                              v2.getX().atan2(v2.getZ().negate()));\n\n        } else if (order == RotationOrder.YZY) {\n\n            // r (+J) coordinates are :\n            //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n            // (-r) (+J) coordinates are :\n            // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n            // and we can choose to have psi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 1, 0));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 1, 0));\n            if ((v2.getY().getReal() < -0.9999999999) || (v2.getY().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getZ().atan2(v1.getX().negate()),\n                              v2.getY().acos(),\n                              v2.getZ().atan2(v2.getX()));\n\n        } else if (order == RotationOrder.ZXZ) {\n\n            // r (+K) coordinates are :\n            //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n            // (-r) (+K) coordinates are :\n            // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n            // and we can choose to have phi in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getX().atan2(v1.getY().negate()),\n                              v2.getZ().acos(),\n                              v2.getX().atan2(v2.getY()));\n\n        } else { // last possibility is ZYZ\n\n            // r (+K) coordinates are :\n            //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n            // (-r) (+K) coordinates are :\n            // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n            // and we can choose to have theta in the interval [0 ; PI]\n            final FieldVector3D<T> v1 = applyTo(vector(0, 0, 1));\n            final FieldVector3D<T> v2 = applyInverseTo(vector(0, 0, 1));\n            if ((v2.getZ().getReal() < -0.9999999999) || (v2.getZ().getReal() > 0.9999999999)) {\n                throw new CardanEulerSingularityException(false);\n            }\n            return buildArray(v1.getY().atan2(v1.getX()),\n                              v2.getZ().acos(),\n                              v2.getY().atan2(v2.getX().negate()));\n\n        }\n\n    }"
}