{
          "0": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (24 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "1": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (2 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "2": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (1 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "3": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "4": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 - hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "5": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "6": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "7": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 + hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "8": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 <= hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "9": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 & hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "10": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 >= hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "11": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\ndays += (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "12": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 / hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "13": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 >> hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "14": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 > hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "15": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (-1 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "16": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 * hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "17": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (0 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "18": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours = 0;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "19": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\ndays = 0;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "20": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (24 * days);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "21": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours = 0;\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "22": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\ndays = 0;\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "23": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes = 0;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "24": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nseconds += (60 * minutes);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "25": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (24 * days);\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "26": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nif(!Token.containsTokenWithValue(tokens, H)){\n            minutes += 60 % hours;            hours = 0;\n}\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "27": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes = 0;\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "28": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nseconds += (60 * minutes);\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "29": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours -= (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "30": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours *= (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "31": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nreturn;\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "32": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 % days);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "33": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (false % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "34": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\ndays -= (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "35": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nif(!Token.containsTokenWithValue(tokens, d)){\n            minutes += 60 % hours;            hours = 0;\n}\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "36": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\ndays *= (60 % hours);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "37": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 % H);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "38": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nif((60 % hours)){\n            minutes += 60 % hours;            hours = 0;\n}\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "39": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 % d);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "40": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nminutes += (60 % tokens);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "41": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nreturn;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "42": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (60 + (60 % hours));\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "43": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nbreak;\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "44": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 % hours;            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "45": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (60 + days);\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "46": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (60 + (d * days));\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }",
          "47": "    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n            final TimeZone timezone) {\n\n        // Used to optimise for differences under 28 days and \n        // called formatDuration(millis, format); however this did not work \n        // over leap years. \n        // TODO: Compare performance to see if anything was lost by \n        // losing this optimisation. \n        \n        final Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n       \n        if (Token.containsTokenWithValue(tokens, M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n\n            while (months < 0) {\n                months += 12;\n                years -= 1;\n            }\n\n            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        } else {\n            // there are no M's in the format string\n\n            if( !Token.containsTokenWithValue(tokens, y) ) {\n                int target = end.get(Calendar.YEAR);\n                if (months < 0) {\n                    // target is end-year -1\n                    target -= 1;\n                }\n                \n                while (start.get(Calendar.YEAR) != target) {\n                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                    \n                    // Not sure I grok why this is needed, but the brutal tests show it is\n                    if (start instanceof GregorianCalendar &&\n                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n                        days += 1;\n                    }\n                    \n                    start.add(Calendar.YEAR, 1);\n                    \n                    days += start.get(Calendar.DAY_OF_YEAR);\n                }\n                \n                years = 0;\n            }\n            \n            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                start.add(Calendar.MONTH, 1);\n            }\n            \n            months = 0;            \n\n            while (days < 0) {\n                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                months -= 1;\n                start.add(Calendar.MONTH, 1);\n            }\n            \n        }\n\n        // The rest of this code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\nhours += (60 + (d * d));\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }"
}