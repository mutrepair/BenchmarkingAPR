{
          "0": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 2) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "1": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 1) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "2": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 3) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "3": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 15) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "4": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "5": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 0) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "6": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((i * 16) / j)){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "7": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * true) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "8": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * false) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "9": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) / j)]){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "10": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse16[i]){\ncontinue;\n}\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "11": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((i * 16)){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "12": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbsW(1, 1);\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "13": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbsW(1, 0);\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "14": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbsW(15, nSelectors);\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "15": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[i]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "16": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbsW(3, nGroups);\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "17": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "18": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ninUse16[i] = true;\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "19": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(blockRandomised){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "20": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(firstAttempt){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "21": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(closed){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "22": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((j < 16)){\ncontinue;\n}\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "23": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(blockRandomised[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "24": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(firstAttempt[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "25": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(closed[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "26": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(nGroups[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "27": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ninUse16[i] = false;\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "28": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\npanic();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "29": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nmakeMaps();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "30": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nwriteRun();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "31": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nfinalize();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "32": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nclose();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "33": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nfinish();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "34": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nflush();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "35": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ninitialize();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "36": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ninitBlock();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "37": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nendBlock();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "38": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nendCompression();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "39": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbsFinishedWithStream();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "40": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nsendMTFValues();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "41": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nmoveToFrontCodeAndSend();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "42": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nmainSort();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "43": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nrandomiseBlock();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "44": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ndoReversibleTransformation();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "45": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nallocateCompressStructures();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "46": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ngenerateMTFValues();\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "47": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) + j)]){\ncontinue;\n}\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "48": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(i[i]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "49": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((i * 16) / j)){\ncontinue;\n}\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "50": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(i[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "51": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((i * 16)){\ncontinue;\n}\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "52": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(i){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "53": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "54": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(i[((i * 16) / j)]){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "55": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(nGroups[i]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "56": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(j){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "57": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(nGroups){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "58": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(j[i]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "59": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) + j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "60": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(j[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "61": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(nSelectors[((i * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "62": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) / inUse)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "63": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((inUse * 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "64": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse16){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "65": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * \"null\") / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "66": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * null) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "67": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nreturn;\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "68": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nfor(j = 0(j < 16);j++) {                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "69": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "70": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) <= j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "71": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((((i * 16) / j) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "72": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nbreak;\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "73": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) >= j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "74": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((((i * 16) / j) && (j < 16))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "75": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) > j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "76": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i >= 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "77": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i <= 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "78": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i * 16) < j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "79": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(inUse[((i > 16) / j)]){                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "80": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] != inUse[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "81": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse != inUse[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "82": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] == inUse[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "83": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse == inUse[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "84": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\ncontinue;\n                        if (inUse[i * 16 / j]) {                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "85": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] != inUse)){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "86": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] > inUse[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "87": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] == inUse)){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "88": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] != i[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "89": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif((inUse[((i * 16) / j)] == i[((i * 16) / j)])){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "90": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse == inUse) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "91": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "92": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "93": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != null) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "94": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse == inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "95": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "96": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((i != inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "97": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((i == inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "98": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != i[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "99": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] == inUse[((i * 16) / j)]) && ((i * 16) / j))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "100": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse != null))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "101": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse != inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "102": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse == inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "103": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse == inUse[((i * 16) / j)]) && (inUse == inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "104": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse != inUse[((i * 16) / j)]))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "105": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse == inUse[((i * 16) / j)]) && (inUse != inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "106": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse == i))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "107": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && (inUse != null))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "108": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse == inUse[((i * 16) / j)]))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "109": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && (inUse == inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "110": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && (inUse != inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "111": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse != inUse[((i * 16) / j)]) && (inUse != i[((i * 16) / j)]))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "112": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && (inUse != inUse[((i * 16) / j)]))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "113": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n                gs = ge + 1;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\nif(((inUse[((i * 16) / j)] != inUse[((i * 16) / j)]) && (inUse > inUse))){\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }"
}