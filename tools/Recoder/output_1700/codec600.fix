{
          "0": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 0;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "1": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 2;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "2": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "3": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i <= numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "4": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i >= numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "5": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < i);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "6": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "7": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = -1;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "8": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == 0)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "9": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = false;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "10": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) || (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "11": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i > numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "12": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple != null)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "13": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "14": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) && (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "15": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = true;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "16": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((i < numberQuadruple)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "17": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple != 0)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "18": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == null)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "19": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < i);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "20": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == 0)){\ncontinue;\n}        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "21": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((i == 0)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "22": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i <= (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "23": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == numberQuadruple)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "24": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple < 0)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "25": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < );i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "26": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = \"null\";(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "27": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\ni++;\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "28": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nreturn;\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "29": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple > 0)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "30": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple <= (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "31": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(final int i = 1;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "32": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == 0)){\nreturn;\n}        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "33": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i > (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "34": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "35": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = null;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "36": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = (i < numberQuadruple);(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "37": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((i == 0)){\ncontinue;\n}        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "38": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple - 1));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "39": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == numberQuadruple)){\ncontinue;\n}        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "40": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple - numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "41": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i - numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "42": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nnumberQuadruple = numberQuadruple;\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "43": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nnumberQuadruple++;\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "44": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple < numberQuadruple)){\n        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n}\n    }",
          "45": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < numberQuadruple);i++) {        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "46": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) < (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "47": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 1; i < numberQuadruple; i++) {if(0!=1)break;            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "48": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < );i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "49": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n((i < (i < numberQuadruple)))            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "50": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n((i < numberQuadruple))            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "51": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i == numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "52": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple > (i < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "53": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple - 0));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "54": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (numberQuadruple - numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "55": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nif((numberQuadruple == null)){\ncontinue;\n}        for (int i = 1; i < numberQuadruple; i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "56": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) || (numberQuadruple < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "57": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (numberQuadruple - i));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "58": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (numberQuadruple - 1));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "59": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;;i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "60": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < -numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "61": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = -2;(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "62": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < numberQuadruple);numberQuadruple) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "63": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (numberQuadruple - 0));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "64": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i >> numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "65": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple - i));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "66": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple + numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "67": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = (numberQuadruple - numberQuadruple);(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "68": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < (numberQuadruple - 2));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "69": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (i - numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "70": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (numberQuadruple + numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "71": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) || (numberQuadruple < i));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "72": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < -i);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "73": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = (numberQuadruple - 1);(i < numberQuadruple);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "74": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;((i < numberQuadruple) && (numberQuadruple < numberQuadruple));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "75": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(numberQuadruple < (i - 1));i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "76": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\nfor(int i = 1;(i < numberQuadruple++);i++) {            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }"
}