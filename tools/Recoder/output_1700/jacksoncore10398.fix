{
          "0": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr <= safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "1": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr >= safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "2": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "3": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr > safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "4": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr - safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "5": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((b24 < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "6": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < b24)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "7": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((_outputTail < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "8": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < _outputTail)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "9": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((safeOutputEnd < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "10": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < safeOutputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "11": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < _outputBuffer)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "12": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((_outputBuffer < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "13": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((safeInputEnd < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "14": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < inputPtr)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "15": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr >> safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "16": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr == safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "17": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr + safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "18": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "19": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr >>> safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "20": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(((int)input[inputPtr++] & 0xFF)){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "21": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((b24 << 8)){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "22": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr / safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "23": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((-inputPtr < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "24": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((-safeInputEnd < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "25": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(inputPtr){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "26": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < -safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "27": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < -inputPtr)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "28": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(safeInputEnd){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "29": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwriteStartArray();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "30": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwriteEndArray();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "31": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwriteStartObject();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "32": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwriteEndObject();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "33": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwriteNull();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "34": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nflush();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "35": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nclose();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "36": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n_releaseBuffers();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "37": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n_writeNull();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "38": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n_flushBuffer();\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "39": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((-_outputTail < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "40": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(((b24 << 8) | ((int)input[inputPtr++] & 0xFF))){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "41": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((-_outputBuffer < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "42": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nbreak;\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "43": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((b64variant.getMaxLineLength() >> 2)){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "44": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((-input < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "45": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < -_outputTail)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "46": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((inputPtr < -_outputBuffer)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "47": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((~safeInputEnd < safeInputEnd)){            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "48": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile((--chunksBeforeLF <= 0)){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "49": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(((inputPtr < safeInputEnd) || (safeInputEnd < 0))){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "50": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(((inputPtr < safeInputEnd) || (_outputTail < 0))){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "51": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nwhile(((inputPtr < safeInputEnd) || (safeInputEnd < 1))){\n\n}            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "52": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\nreturn;\n        while (inputPtr < safeInputEnd) {            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }"
}