{
          "0": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "1": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "2": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "3": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "4": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "5": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "6": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "7": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "8": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "9": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "10": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "11": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "12": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "13": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "14": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "15": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "16": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "17": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "18": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "19": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "20": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "21": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "22": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "23": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "24": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "25": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "26": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "27": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "28": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "29": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "30": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "31": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "32": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "33": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "34": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "35": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "36": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "37": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "38": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "39": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "40": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "41": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "42": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "43": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "44": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "45": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "46": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "47": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "48": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "49": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "50": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "51": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "52": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "53": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "54": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!inf.isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "55": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nclearResolved();\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "56": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isSubtype(that) || isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "57": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasDisplayName())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "58": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "59": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoResolvedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "60": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "61": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "62": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumberObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "63": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumberValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "64": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isFunctionPrototypeType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "65": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStringObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "66": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTheObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "67": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStringValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "68": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isString())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "69": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumber())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "70": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isArrayType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "71": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isBooleanObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "72": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isBooleanValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "73": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isRegexpType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "74": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isDateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "75": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNullType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "76": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isVoidType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "77": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isAllType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "78": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "79": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isCheckedUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "80": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isUnionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "81": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStruct())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "82": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isDict())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "83": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isGlobalThisType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "84": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isFunctionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "85": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEnumElementType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "86": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEnumType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "87": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNamedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "88": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isRecordType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "89": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isParameterizedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "90": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTemplateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "91": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasAnyTemplateTypes())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "92": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasAnyTemplateTypesInternal())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "93": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTemplatized())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "94": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isObject())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "95": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "96": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNominalType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "97": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNominalConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "98": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isInstanceType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "99": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isInterface())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "100": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isOrdinaryFunction())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "101": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesInt32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "102": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesUint32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "103": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesNumberContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "104": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesStringContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "105": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesObjectContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "106": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || canBeCalled())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "107": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNullable())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "108": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isResolved())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "109": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(that.isSubtype(this)){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "110": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isSubtype(that) && isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "111": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasDisplayName())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "112": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "113": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoResolvedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "114": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "115": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "116": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumberObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "117": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumberValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "118": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isFunctionPrototypeType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "119": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStringObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "120": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTheObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "121": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStringValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "122": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isString())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "123": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumber())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "124": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isArrayType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "125": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isBooleanObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "126": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isBooleanValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "127": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isRegexpType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "128": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isDateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "129": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNullType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "130": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isVoidType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "131": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isAllType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "132": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "133": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isCheckedUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "134": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isUnionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "135": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStruct())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "136": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isDict())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "137": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isGlobalThisType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "138": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isFunctionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "139": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEnumElementType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "140": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEnumType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "141": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNamedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "142": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isRecordType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "143": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isParameterizedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "144": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTemplateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "145": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasAnyTemplateTypes())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "146": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasAnyTemplateTypesInternal())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "147": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTemplatized())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "148": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isObject())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "149": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "150": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNominalType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "151": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNominalConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "152": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isInstanceType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "153": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isInterface())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "154": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isOrdinaryFunction())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "155": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesInt32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "156": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesUint32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "157": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesNumberContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "158": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesStringContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "159": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesObjectContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "160": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !canBeCalled())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "161": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNullable())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "162": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isResolved())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "163": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasDisplayName())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "164": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "165": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoResolvedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "166": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "167": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "168": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumberObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "169": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumberValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "170": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isFunctionPrototypeType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "171": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStringObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "172": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTheObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "173": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStringValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "174": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isString())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "175": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumber())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "176": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isArrayType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "177": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isBooleanObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "178": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isBooleanValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "179": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isRegexpType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "180": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isDateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "181": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNullType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "182": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isVoidType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "183": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isAllType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "184": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "185": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isCheckedUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "186": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isUnionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "187": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStruct())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "188": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isDict())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "189": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isGlobalThisType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "190": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isFunctionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "191": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEnumElementType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "192": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEnumType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "193": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNamedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "194": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isRecordType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "195": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isParameterizedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "196": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTemplateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "197": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasAnyTemplateTypes())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "198": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasAnyTemplateTypesInternal())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "199": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTemplatized())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "200": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isObject())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "201": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "202": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNominalType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "203": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNominalConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "204": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isInstanceType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "205": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isInterface())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "206": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isOrdinaryFunction())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "207": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesInt32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "208": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesUint32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "209": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesNumberContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "210": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesStringContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "211": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesObjectContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "212": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && canBeCalled())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "213": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNullable())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "214": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isResolved())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "215": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(registry.isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "216": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !hasDisplayName())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "217": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNoType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "218": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNoResolvedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "219": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNoObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "220": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "221": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNumberObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "222": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNumberValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "223": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isFunctionPrototypeType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "224": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isStringObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "225": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isTheObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "226": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isStringValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "227": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isString())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "228": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNumber())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "229": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isArrayType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "230": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isBooleanObjectType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "231": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isBooleanValueType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "232": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isRegexpType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "233": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isDateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "234": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNullType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "235": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isVoidType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "236": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isAllType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "237": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "238": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isCheckedUnknownType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "239": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isUnionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "240": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isStruct())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "241": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isDict())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "242": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isGlobalThisType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "243": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isFunctionType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "244": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isEnumElementType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "245": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isEnumType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "246": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNamedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "247": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isRecordType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "248": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isParameterizedType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "249": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isTemplateType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "250": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !hasAnyTemplateTypes())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "251": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !hasAnyTemplateTypesInternal())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "252": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isTemplatized())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "253": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isObject())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "254": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "255": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNominalType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "256": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNominalConstructor())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "257": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isInstanceType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "258": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isInterface())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "259": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isOrdinaryFunction())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "260": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !matchesInt32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "261": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !matchesUint32Context())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "262": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !matchesNumberContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "263": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !matchesStringContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "264": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !matchesObjectContext())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "265": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !canBeCalled())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "266": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isNullable())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "267": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && !isResolved())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "268": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType(that)){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "269": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isSubtype(that)){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "270": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(that.isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "271": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((!inf.isEmptyType() || isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "272": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "273": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "274": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "275": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "276": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "277": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "278": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "279": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "280": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "281": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "282": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "283": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "284": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "285": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "286": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "287": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "288": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "289": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "290": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "291": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "292": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "293": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "294": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "295": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "296": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "297": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "298": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "299": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "300": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "301": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "302": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "303": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "304": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "305": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "306": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "307": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "308": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "309": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "310": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "311": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "312": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "313": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "314": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "315": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "316": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "317": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "318": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "319": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "320": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "321": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "322": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "323": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "324": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "325": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || that.isSubtype(this))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "326": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((!inf.isEmptyType() && isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "327": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasDisplayName()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "328": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "329": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoResolvedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "330": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "331": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "332": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "333": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "334": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionPrototypeType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "335": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "336": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTheObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "337": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "338": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isString()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "339": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumber()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "340": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isArrayType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "341": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "342": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "343": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRegexpType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "344": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDateType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "345": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "346": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isVoidType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "347": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isAllType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "348": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnknownType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "349": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isCheckedUnknownType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "350": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnionType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "351": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStruct()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "352": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDict()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "353": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isGlobalThisType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "354": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "355": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumElementType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "356": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "357": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNamedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "358": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRecordType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "359": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isParameterizedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "360": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplateType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "361": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypes()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "362": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypesInternal()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "363": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplatized()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "364": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isObject()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "365": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isConstructor()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "366": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "367": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalConstructor()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "368": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInstanceType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "369": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInterface()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "370": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isOrdinaryFunction()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "371": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesInt32Context()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "372": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesUint32Context()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "373": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesNumberContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "374": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesStringContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "375": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesObjectContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "376": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!canBeCalled()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "377": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullable()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "378": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isResolved()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "379": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "380": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(that){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "381": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && that.isSubtype(this))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "382": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "383": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "384": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "385": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "386": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "387": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "388": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "389": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "390": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "391": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "392": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "393": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "394": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "395": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "396": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "397": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "398": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "399": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "400": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "401": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "402": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "403": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "404": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "405": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "406": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "407": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "408": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "409": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "410": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "411": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "412": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "413": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "414": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "415": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "416": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "417": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "418": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "419": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "420": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "421": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "422": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "423": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "424": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "425": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "426": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "427": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "428": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "429": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "430": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "431": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "432": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "433": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "434": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(registry.isEmptyType(that)){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "435": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "436": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that == null)){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "437": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(JSTypeNative.isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "438": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasDisplayName()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "439": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "440": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoResolvedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "441": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "442": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "443": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "444": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "445": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionPrototypeType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "446": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "447": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTheObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "448": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "449": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isString()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "450": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumber()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "451": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isArrayType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "452": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "453": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "454": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRegexpType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "455": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDateType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "456": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "457": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isVoidType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "458": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isAllType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "459": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnknownType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "460": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isCheckedUnknownType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "461": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnionType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "462": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStruct()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "463": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDict()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "464": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isGlobalThisType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "465": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "466": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumElementType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "467": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "468": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNamedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "469": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRecordType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "470": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isParameterizedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "471": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplateType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "472": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypes()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "473": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypesInternal()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "474": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplatized()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "475": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isObject()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "476": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isConstructor()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "477": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "478": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalConstructor()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "479": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInstanceType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "480": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInterface()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "481": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isOrdinaryFunction()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "482": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesInt32Context()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "483": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesUint32Context()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "484": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesNumberContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "485": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesStringContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "486": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesObjectContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "487": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!canBeCalled()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "488": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullable()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "489": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isResolved()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "490": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasDisplayName(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "491": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "492": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoResolvedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "493": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNoObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "494": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEmptyType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "495": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumberObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "496": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumberValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "497": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isFunctionPrototypeType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "498": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStringObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "499": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTheObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "500": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStringValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "501": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isString(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "502": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNumber(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "503": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isArrayType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "504": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isBooleanObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "505": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isBooleanValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "506": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isRegexpType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "507": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isDateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "508": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNullType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "509": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isVoidType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "510": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isAllType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "511": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "512": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isCheckedUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "513": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isUnionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "514": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isStruct(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "515": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isDict(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "516": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isGlobalThisType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "517": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isFunctionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "518": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEnumElementType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "519": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isEnumType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "520": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNamedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "521": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isRecordType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "522": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isParameterizedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "523": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTemplateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "524": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasAnyTemplateTypes(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "525": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || hasAnyTemplateTypesInternal(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "526": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isTemplatized(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "527": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isObject(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "528": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "529": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNominalType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "530": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNominalConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "531": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isInstanceType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "532": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isInterface(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "533": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isOrdinaryFunction(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "534": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesInt32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "535": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesUint32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "536": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesNumberContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "537": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesStringContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "538": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || matchesObjectContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "539": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || canBeCalled(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "540": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isNullable(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "541": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || isResolved(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "542": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasDisplayName()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "543": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "544": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoResolvedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "545": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "546": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "547": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "548": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionPrototypeType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "549": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "550": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTheObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "551": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "552": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isString()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "553": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumber()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "554": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isArrayType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "555": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanObjectType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "556": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanValueType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "557": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRegexpType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "558": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDateType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "559": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "560": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isVoidType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "561": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isAllType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "562": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnknownType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "563": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isCheckedUnknownType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "564": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnionType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "565": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStruct()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "566": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDict()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "567": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isGlobalThisType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "568": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "569": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumElementType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "570": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "571": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNamedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "572": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRecordType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "573": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isParameterizedType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "574": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplateType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "575": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypes()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "576": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypesInternal()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "577": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplatized()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "578": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isObject()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "579": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isConstructor()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "580": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "581": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalConstructor()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "582": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInstanceType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "583": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInterface()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "584": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isOrdinaryFunction()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "585": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesInt32Context()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "586": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesUint32Context()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "587": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesNumberContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "588": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesStringContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "589": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesObjectContext()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "590": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!canBeCalled()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "591": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullable()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "592": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isResolved()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "593": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "594": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "595": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "596": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "597": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "598": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "599": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "600": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "601": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "602": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "603": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "604": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "605": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "606": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "607": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "608": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "609": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "610": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "611": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "612": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "613": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "614": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "615": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "616": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "617": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "618": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "619": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "620": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "621": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "622": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "623": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "624": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "625": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "626": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "627": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "628": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "629": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "630": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "631": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "632": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "633": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "634": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "635": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "636": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "637": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "638": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "639": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "640": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "641": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "642": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "643": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "644": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "645": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nsuper.canTestForShallowEqualityWith();\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "646": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasDisplayName()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "647": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "648": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoResolvedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "649": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "650": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "651": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "652": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "653": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionPrototypeType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "654": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "655": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTheObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "656": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "657": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isString()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "658": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumber()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "659": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isArrayType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "660": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "661": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "662": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRegexpType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "663": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDateType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "664": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "665": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isVoidType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "666": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isAllType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "667": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnknownType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "668": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isCheckedUnknownType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "669": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnionType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "670": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStruct()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "671": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDict()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "672": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isGlobalThisType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "673": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "674": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumElementType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "675": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "676": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNamedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "677": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRecordType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "678": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isParameterizedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "679": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplateType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "680": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypes()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "681": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypesInternal()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "682": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplatized()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "683": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isObject()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "684": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isConstructor()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "685": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "686": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalConstructor()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "687": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInstanceType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "688": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInterface()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "689": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isOrdinaryFunction()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "690": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesInt32Context()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "691": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesUint32Context()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "692": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesNumberContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "693": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesStringContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "694": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesObjectContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "695": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!canBeCalled()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "696": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullable()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "697": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isResolved()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "698": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "699": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nthat = clearResolved();\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "700": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that || isEmptyType())){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "701": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasDisplayName()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "702": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "703": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoResolvedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "704": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNoObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "705": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEmptyType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "706": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "707": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumberValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "708": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionPrototypeType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "709": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "710": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTheObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "711": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStringValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "712": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isString()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "713": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNumber()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "714": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isArrayType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "715": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "716": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isBooleanValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "717": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRegexpType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "718": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDateType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "719": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "720": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isVoidType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "721": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isAllType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "722": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnknownType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "723": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isCheckedUnknownType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "724": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isUnionType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "725": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isStruct()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "726": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isDict()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "727": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isGlobalThisType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "728": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isFunctionType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "729": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumElementType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "730": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isEnumType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "731": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNamedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "732": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isRecordType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "733": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isParameterizedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "734": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplateType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "735": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypes()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "736": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!hasAnyTemplateTypesInternal()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "737": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isTemplatized()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "738": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isObject()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "739": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isConstructor()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "740": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "741": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNominalConstructor()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "742": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInstanceType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "743": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isInterface()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "744": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isOrdinaryFunction()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "745": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesInt32Context()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "746": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesUint32Context()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "747": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesNumberContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "748": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesStringContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "749": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!matchesObjectContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "750": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!canBeCalled()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "751": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isNullable()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "752": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!isResolved()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "753": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasDisplayName(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "754": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "755": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoResolvedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "756": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNoObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "757": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEmptyType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "758": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumberObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "759": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumberValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "760": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isFunctionPrototypeType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "761": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStringObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "762": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTheObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "763": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStringValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "764": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isString(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "765": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNumber(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "766": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isArrayType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "767": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isBooleanObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "768": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isBooleanValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "769": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isRegexpType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "770": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isDateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "771": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNullType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "772": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isVoidType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "773": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isAllType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "774": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "775": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isCheckedUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "776": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isUnionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "777": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isStruct(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "778": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isDict(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "779": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isGlobalThisType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "780": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isFunctionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "781": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEnumElementType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "782": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isEnumType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "783": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNamedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "784": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isRecordType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "785": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isParameterizedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "786": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTemplateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "787": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasAnyTemplateTypes(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "788": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && hasAnyTemplateTypesInternal(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "789": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isTemplatized(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "790": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isObject(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "791": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "792": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNominalType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "793": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNominalConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "794": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isInstanceType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "795": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isInterface(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "796": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isOrdinaryFunction(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "797": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesInt32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "798": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesUint32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "799": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesNumberContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "800": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesStringContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "801": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && matchesObjectContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "802": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && canBeCalled(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "803": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isNullable(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "804": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && isResolved(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "805": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((!inf.isEmptyType() || that.isSubtype(this))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "806": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(this.isEmptyType()){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "807": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isSubtype()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "808": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || (that == null))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "809": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "810": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "811": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "812": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "813": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "814": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "815": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "816": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "817": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "818": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "819": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "820": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "821": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "822": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "823": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "824": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "825": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "826": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "827": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "828": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "829": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "830": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "831": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "832": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "833": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "834": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "835": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "836": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "837": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "838": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "839": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "840": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "841": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "842": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "843": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "844": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "845": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "846": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "847": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "848": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "849": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "850": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "851": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "852": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "853": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "854": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "855": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "856": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "857": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "858": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "859": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "860": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "861": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isSubtype(that) || that.isSubtype(this))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "862": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasDisplayName()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "863": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "864": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoResolvedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "865": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNoObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "866": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "867": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "868": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumberValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "869": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionPrototypeType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "870": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "871": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTheObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "872": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStringValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "873": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isString()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "874": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNumber()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "875": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isArrayType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "876": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanObjectType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "877": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isBooleanValueType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "878": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRegexpType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "879": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDateType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "880": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "881": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isVoidType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "882": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isAllType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "883": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnknownType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "884": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isCheckedUnknownType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "885": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isUnionType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "886": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isStruct()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "887": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isDict()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "888": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isGlobalThisType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "889": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isFunctionType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "890": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumElementType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "891": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEnumType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "892": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNamedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "893": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isRecordType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "894": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isParameterizedType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "895": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplateType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "896": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypes()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "897": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(hasAnyTemplateTypesInternal()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "898": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isTemplatized()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "899": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isObject()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "900": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isConstructor()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "901": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "902": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNominalConstructor()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "903": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInstanceType()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "904": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isInterface()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "905": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isOrdinaryFunction()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "906": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesInt32Context()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "907": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesUint32Context()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "908": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesNumberContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "909": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesStringContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "910": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(matchesObjectContext()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "911": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canBeCalled()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "912": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isNullable()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "913": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isResolved()){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "914": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!that){\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n}\n  }",
          "915": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || (that != null))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "916": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && (that != null))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "917": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!that){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "918": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that != null)){\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n}\n  }",
          "919": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() && (that == null))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "920": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that == null)){\nreturn (!inf.isEmptyType() || (inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE)));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "921": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(canTestForShallowEqualityWith()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "922": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nisEmptyType();\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "923": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasDisplayName(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "924": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "925": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoResolvedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "926": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNoObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "927": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEmptyType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "928": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumberObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "929": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumberValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "930": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isFunctionPrototypeType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "931": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStringObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "932": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTheObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "933": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStringValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "934": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isString(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "935": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNumber(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "936": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isArrayType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "937": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isBooleanObjectType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "938": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isBooleanValueType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "939": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isRegexpType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "940": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isDateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "941": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNullType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "942": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isVoidType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "943": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isAllType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "944": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "945": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isCheckedUnknownType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "946": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isUnionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "947": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isStruct(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "948": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isDict(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "949": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isGlobalThisType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "950": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isFunctionType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "951": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEnumElementType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "952": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isEnumType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "953": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNamedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "954": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isRecordType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "955": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isParameterizedType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "956": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTemplateType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "957": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasAnyTemplateTypes(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "958": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !hasAnyTemplateTypesInternal(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "959": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isTemplatized(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "960": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isObject(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "961": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "962": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNominalType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "963": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNominalConstructor(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "964": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isInstanceType(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "965": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isInterface(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "966": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isOrdinaryFunction(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "967": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesInt32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "968": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesUint32Context(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "969": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesNumberContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "970": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesStringContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "971": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !matchesObjectContext(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "972": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !canBeCalled(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "973": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isNullable(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "974": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || !isResolved(that))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "975": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that == null)){\nreturn true;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "976": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that == null)){\nreturn (isSubtype(that) || that.isSubtype(this));}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "977": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((that != null)){\nreturn false;}    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "978": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(getNativeType()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "979": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(getGreatestSubtype()){      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "980": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(!inf.isEmptyType()){\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n}\n  }",
          "981": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE))){\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n}\n  }",
          "982": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nreturn;\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }",
          "983": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif(isEmptyType()){\n    if (isEmptyType()) {      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n}\n  }",
          "984": "  public final boolean canTestForShallowEqualityWith(JSType that) {\nif((isEmptyType() || (that == 0))){\n      return isSubtype(that) || that.isSubtype(this);\n    }\n\n    JSType inf = getGreatestSubtype(that);\n    return !inf.isEmptyType() ||\n        // Our getGreatestSubtype relation on functions is pretty bad.\n        // Let's just say it's always ok to compare two functions.\n        // Once the TODO in FunctionType is fixed, we should be able to\n        // remove this.\n        inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n  }"
}