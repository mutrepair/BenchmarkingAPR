{
          "0": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(true){                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "1": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "2": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EOF;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "3": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.isReady = true;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "4": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = TOKEN;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "5": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EORECORD;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "6": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "7": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)c);\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "8": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nc = in.read();\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "9": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)readEscape(c));\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "10": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntrimTrailingSpaces(tkn.content);\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "11": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(false){                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "12": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nreturn tkn;            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "13": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(surroundingSpacesIgnored){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "14": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(c){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "15": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(\"null\"){                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "16": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(surroundingSpacesIgnored){\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n}\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "17": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(tkn){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "18": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(-true){                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "19": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nreturn null;            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "20": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(isDelimiter(c)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "21": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nreturn;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "22": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c != null)){\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n}\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "23": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ncontinue;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "24": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nc = false;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "25": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nbreak;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "26": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EOF;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "27": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.isReady = true;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "28": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(isEndOfFile(c)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "29": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = TOKEN;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "30": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EORECORD;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "31": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif(isEndOfLine(c)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "32": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nbreak;\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "33": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c != null)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "34": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nc = in.read();\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "35": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)c);\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "36": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntrimTrailingSpaces(tkn.content);\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "37": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)readEscape(c));\nbreak;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "38": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nreturn this;            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "39": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c == null)){\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n}\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "40": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.isReady = true;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "41": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = TOKEN;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "42": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((tkn != null)){\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n}\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "43": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c && null)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "44": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c == null)){\nbreak;\n}            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "45": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EOF;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "46": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.type = EORECORD;\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "47": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntrimTrailingSpaces(tkn.content);\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "48": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c && false)){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "49": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nc = in.read();\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "50": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\n            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "51": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)c);\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "52": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c != null)){\nbreak;\n}            } else if (false) {                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "53": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\ntkn.content.append((char)readEscape(c));\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }",
          "54": "    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n        while (true) {\n            if (isEndOfLine(c)) {\n                // end of record\n                tkn.type = EORECORD;\n                break;\n            } else if (isEndOfFile(c)) {\n                // end of file\n                tkn.type = EOF;\n                tkn.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(c)) {\n                // end of token\n                tkn.type = TOKEN;\n                break;\nif((c && (c != null))){\n                tkn.content.append((char) readEscape(c));\n            } else {\n                tkn.content.append((char) c);\n            }\n\n            c = in.read();\n        }\n\n        if (surroundingSpacesIgnored) {\n            trimTrailingSpaces(tkn.content);\n        }\n\n        return tkn;\n    }"
}