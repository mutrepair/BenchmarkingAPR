{
          "0": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 0,i = 0;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "1": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 2,i = 2;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "2": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "3": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i <= n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "4": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i >= n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "5": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "6": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);n) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "7": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "8": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = -1,i = -1;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "9": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(n < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "10": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;((i < n) || (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "11": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i > n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "12": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;((i < n) && (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "13": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);-i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "14": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i - n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "15": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n((i < n))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "16": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < i);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "17": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n((i < n))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "18": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n((i < (i < n)))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "19": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i <= (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "20": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i == n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "21": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i > (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "22": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif((i == 0)){\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n}\n    }",
          "23": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif((i == 0)){\ncontinue;\n}      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "24": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = false,i = false;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "25": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < alternatives.size());++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "26": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nreturn;\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "27": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(-i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "28": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nbreak;\n        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "29": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;;++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "30": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);size) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "31": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n(((i < n) || (i < n)))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "32": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < 0);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "33": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = \"null\",i = \"null\";(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "34": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif((i != null)){\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n}\n    }",
          "35": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {if(0!=1)break;        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "36": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);!i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "37": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i == (i < n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "38": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;( < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "39": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif((i == 0)){\nreturn;\n}      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "40": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif(alternatives.size()){\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n}\n    }",
          "41": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n(((i < n) && (i < n)))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "42": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;alternatives.size();++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "43": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int n = ;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "44": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i >> n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "45": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);i++) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "46": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nif((i < n)){\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n}\n    }",
          "47": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "48": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = -2,i = -2;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "49": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (n - n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "50": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nalternatives.size();\n      for (int i = 1, n = alternatives.size(); i < n; ++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "51": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = true,i = true;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "52": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(size < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "53": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i >>> n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "54": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n((i < n))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "55": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (n - 1));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "56": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (i - n));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "57": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n((i < n))        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "58": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i / n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "59": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = null,i = null;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "60": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (n - 0));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "61": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i * n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "62": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "63": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < n);e) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "64": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;(i < (i - 1));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "65": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\nfor(int i = 1,i = 1;((i < n) || (i < i));++i) {        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }",
          "66": "    public RegExpTree simplify(String flags) {\n      List<RegExpTree> alternatives = Lists.newArrayList();\n      for (RegExpTree alternative : this.alternatives) {\n        alternative = alternative.simplify(flags);\n        if (alternative instanceof Alternation) {\n          alternatives.addAll(((Alternation) alternative).alternatives);\n        } else {\n          alternatives.add(alternative);\n        }\n      }\n      // Remove duplicates\n      RegExpTree last = null;\n      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n        RegExpTree alternative = it.next();\n        if (alternative.equals(NEVER_MATCHES)) { continue; }\n        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n          it.remove();\n        } else {\n          last = alternative;\n        }\n      }\n      // Collapse character alternatives into character sets.\n(;;)        RegExpTree alternative = alternatives.get(i);\n        if ((alternative instanceof Text\n             && ((Text) alternative).text.length() == 1)\n            || alternative instanceof Charset) {\n          int end = i;\n          int nCharsets = 0;\n          while (end < n) {\n            RegExpTree follower = alternatives.get(end);\n            if (follower instanceof Charset) {\n              ++nCharsets;\n            } else if (!(follower instanceof Text\n                         && ((Text) follower).text.length() == 1)) {\n              break;\n            }\n            ++end;\n          }\n          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n            int[] members = new int[end - i - nCharsets];\n            int memberIdx = 0;\n            CharRanges chars = CharRanges.EMPTY;\n            CharRanges ieExplicits = CharRanges.EMPTY;\n            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n            for (RegExpTree charAlternative : charAlternatives) {\n              if (charAlternative instanceof Text) {\n                char ch = ((Text) charAlternative).text.charAt(0);\n                members[memberIdx++] = ch;\n                if (IE_SPEC_ERRORS.contains(ch)) {\n                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n                }\n              } else if (charAlternative instanceof Charset) {\n                Charset cs = (Charset) charAlternative;\n                chars = chars.union(cs.ranges);\n                ieExplicits = ieExplicits.union(cs.ieExplicits);\n              }\n            }\n            chars = chars.union(CharRanges.withMembers(members));\n            charAlternatives.clear();\n            charAlternatives.add(\n                new Charset(chars, ieExplicits).simplify(flags));\n            n = alternatives.size();\n          }\n        }\n      }\n      switch (alternatives.size()) {\n        case 0: return Empty.INSTANCE;\n        case 1: return alternatives.get(0);\n        case 2:\n          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n            return new Repetition(alternatives.get(0), 0, 1, true);\n          } else if (alternatives.get(0) instanceof Empty) {\n            return new Repetition(alternatives.get(1), 0, 1, false);\n          }\n          break;\n      }\n      // TODO: maybe pull out common prefix or suffix\n      return alternatives.equals(this.alternatives)\n          ? this : new Alternation(alternatives);\n    }"
}