{
          "0": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "1": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += 1;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "2": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "3": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ndataStart += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "4": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nlocalDataStart += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "5": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncdOffset += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "6": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncdLength += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "7": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += 2;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "8": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nfinish();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "9": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncloseEntry();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "10": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nclose();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "11": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nflush();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "12": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncloseArchiveEntry();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "13": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ndeflate();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "14": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteCentralDirectoryEnd();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "15": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ndeflateUntilInputIsNeeded();\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "16": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(ZipLong.getBytes(ze.getSize()));\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "17": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(ZipLong.getBytes(ze.getCrc()));\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "18": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nzipMethod += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "19": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(LZERO);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "20": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nLZERO += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "21": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten = 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "22": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nreturn;\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "23": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += -1;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "24": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nreturn;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "25": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += WORD;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "26": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nSHORT += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "27": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nDEFLATED += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "28": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nWORD += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "29": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += null;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "30": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetLevel(0);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "31": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetMethod(0);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "32": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwrite(0);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "33": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nZipShort.getBytes(name.limit());\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "34": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten = 1;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "35": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += false;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "36": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetLevel(written);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "37": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetMethod(written);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "38": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwrite(written);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "39": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += true;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "40": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += written;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "41": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(ZipLong.getBytes(ze.getSize()));\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "42": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetLevel(LZERO);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "43": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetMethod(LZERO);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "44": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwrite(LZERO);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "45": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetLevel(1);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "46": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nsetMethod(1);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "47": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwrite(1);\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "48": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(ZipLong.getBytes(ze.getCrc()));\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "49": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(LZERO);\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "50": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += SHORT;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "51": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwriteOut(ZipShort.getBytes(name.limit()));\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "52": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten -= 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "53": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten = false;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "54": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten = null;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "55": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten = WORD;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "56": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten.written += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "57": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ndataStart.written += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "58": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nlocalDataStart.written += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "59": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncdOffset.written += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "60": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncdLength.written += 0;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "61": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nbreak;\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "62": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\nwritten += (int)WORD;\n        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }",
          "63": "    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n\n        boolean encodable = zipEncoding.canEncode(ze.getName());\n        \n        final ZipEncoding entryEncoding;\n        \n        if (!encodable && fallbackToUTF8) {\n            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n        } else {\n            entryEncoding = zipEncoding;\n        }\n        \n        ByteBuffer name = entryEncoding.encode(ze.getName());        \n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n\n            if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                || !encodable) {\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           name.array(),\n                                                           name.arrayOffset(),\n                                                           name.limit()));\n            }\n\n            String comm = ze.getComment();\n            if (comm != null && !\"\".equals(comm)) {\n\n                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n\n                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                    || !commentEncodable) {\n                    ByteBuffer commentB = entryEncoding.encode(comm);\n                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                  commentB.array(),\n                                                                  commentB.arrayOffset(),\n                                                                  commentB.limit())\n                                     );\n                }\n            }\n        }\n\n        offsets.put(ze, ZipLong.getBytes(written));\n\n        writeOut(LFH_SIG);\n        written += WORD;\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n\n        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                         !encodable\n                                                         && fallbackToUTF8);\n        written += WORD;\n\n        // compression method\n        writeOut(ZipShort.getBytes(zipMethod));\n        written += SHORT;\n\n        // last mod. time and date\n        writeOut(ZipUtil.toDosTime(ze.getTime()));\n        written += WORD;\n\n        // CRC\n        // compressed length\n        // uncompressed length\n        localDataStart = written;\n        if (zipMethod == DEFLATED || raf != null) {\n            writeOut(LZERO);\n            writeOut(LZERO);\n            writeOut(LZERO);\n        } else {\n            writeOut(ZipLong.getBytes(ze.getCrc()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n            writeOut(ZipLong.getBytes(ze.getSize()));\n        }\n        // CheckStyle:MagicNumber OFF\ncontinue;\n        written += 0;        // CheckStyle:MagicNumber ON\n\n        // file name length\n        writeOut(ZipShort.getBytes(name.limit()));\n        written += SHORT;\n\n        // extra field length\n        byte[] extra = ze.getLocalFileDataExtra();\n        writeOut(ZipShort.getBytes(extra.length));\n        written += SHORT;\n\n        // file name\n        writeOut(name.array(), name.arrayOffset(), name.limit());\n        written += name.limit();\n\n        // extra field\n        writeOut(extra);\n        written += extra.length;\n\n        dataStart = written;\n    }"
}