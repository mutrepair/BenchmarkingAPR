{
          "0": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]];        };\n\n    }",
          "1": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "2": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn ((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]));        };\n\n    }",
          "3": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn ((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0]));        };\n\n    }",
          "4": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * r))};        };\n\n    }",
          "5": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * theta))};        };\n\n    }",
          "6": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phi))};        };\n\n    }",
          "7": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian))};        };\n\n    }",
          "8": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * rHessian))};        };\n\n    }",
          "9": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * thetaHessian))};        };\n\n    }",
          "10": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phiHessian))};        };\n\n    }",
          "11": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * x))};        };\n\n    }",
          "12": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * y))};        };\n\n    }",
          "13": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * z))};        };\n\n    }",
          "14": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * r)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "15": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * theta)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "16": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phi)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "17": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "18": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * rHessian)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "19": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * thetaHessian)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "20": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phiHessian)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "21": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * x)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "22": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * y)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "23": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * z)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "24": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn 0;        };\n\n    }",
          "25": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[0].[0]))};        };\n\n    }",
          "26": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn (((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0]));        };\n\n    }",
          "27": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn (((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1]));        };\n\n    }",
          "28": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "29": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\ncomputeJacobian();\n        return new double[] {\n            sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[0][0],\n            sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1],\n            sGradient[0] * jacobian[0][2]                                 + sGradient[2] * jacobian[2][2]        };\n\n    }",
          "30": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\ncomputeHessians();\n        return new double[] {\n            sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[0][0],\n            sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1],\n            sGradient[0] * jacobian[0][2]                                 + sGradient[2] * jacobian[2][2]        };\n\n    }",
          "31": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient))};        };\n\n    }",
          "32": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[1].[1]))};        };\n\n    }",
          "33": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn ((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1]));        };\n\n    }",
          "34": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn 1;        };\n\n    }",
          "35": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[1].[0]))};        };\n\n    }",
          "36": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * r[0].[0]))};        };\n\n    }",
          "37": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * theta[0].[0]))};        };\n\n    }",
          "38": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phi[0].[0]))};        };\n\n    }",
          "39": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[0].[0]))};        };\n\n    }",
          "40": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * rHessian[0].[0]))};        };\n\n    }",
          "41": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * thetaHessian[0].[0]))};        };\n\n    }",
          "42": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phiHessian[0].[0]))};        };\n\n    }",
          "43": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * x[0].[0]))};        };\n\n    }",
          "44": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * y[0].[0]))};        };\n\n    }",
          "45": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * z[0].[0]))};        };\n\n    }",
          "46": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * r[2].[2]))};        };\n\n    }",
          "47": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * theta[2].[2]))};        };\n\n    }",
          "48": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phi[2].[2]))};        };\n\n    }",
          "49": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * rHessian[2].[2]))};        };\n\n    }",
          "50": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * thetaHessian[2].[2]))};        };\n\n    }",
          "51": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phiHessian[2].[2]))};        };\n\n    }",
          "52": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * x[2].[2]))};        };\n\n    }",
          "53": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * y[2].[2]))};        };\n\n    }",
          "54": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * z[2].[2]))};        };\n\n    }",
          "55": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient)),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "56": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[2].[2]))};        };\n\n    }",
          "57": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * sGradient[0].[0]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "58": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[1].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "59": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[1].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "60": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[0].[1]))};        };\n\n    }",
          "61": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * sGradient[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "62": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "63": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * sGradient[2].[1]))};        };\n\n    }",
          "64": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * sGradient) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "65": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "66": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * r[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "67": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * theta[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "68": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phi[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "69": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * rHessian[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "70": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * thetaHessian[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "71": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phiHessian[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "72": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * x[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "73": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * y[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "74": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * z[0].[0])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "75": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * sGradient[0].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "76": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn (sGradient[0] * jacobian[0].[0]);        };\n\n    }",
          "77": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * r) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "78": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * theta) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "79": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * phi) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "80": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "81": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * rHessian) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "82": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * thetaHessian) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "83": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * phiHessian) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "84": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * x) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "85": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * y) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "86": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * z) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "87": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * sGradient[0].[0])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "88": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * r[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "89": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * theta[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "90": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phi[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "91": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "92": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * rHessian[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "93": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * thetaHessian[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "94": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * phiHessian[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "95": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * x[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "96": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * y[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "97": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * z[2].[2])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "98": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[0].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "99": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * r[2].[1]))};        };\n\n    }",
          "100": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * theta[2].[1]))};        };\n\n    }",
          "101": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phi[2].[1]))};        };\n\n    }",
          "102": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[1]))};        };\n\n    }",
          "103": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * rHessian[2].[1]))};        };\n\n    }",
          "104": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * thetaHessian[2].[1]))};        };\n\n    }",
          "105": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phiHessian[2].[1]))};        };\n\n    }",
          "106": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * x[2].[1]))};        };\n\n    }",
          "107": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * y[2].[1]))};        };\n\n    }",
          "108": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * z[2].[1]))};        };\n\n    }",
          "109": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * sGradient[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[2].[2]))};        };\n\n    }",
          "110": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * r[1].[1]))};        };\n\n    }",
          "111": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * theta[1].[1]))};        };\n\n    }",
          "112": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phi[1].[1]))};        };\n\n    }",
          "113": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * jacobian[1].[1]))};        };\n\n    }",
          "114": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * rHessian[1].[1]))};        };\n\n    }",
          "115": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * thetaHessian[1].[1]))};        };\n\n    }",
          "116": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * phiHessian[1].[1]))};        };\n\n    }",
          "117": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * x[1].[1]))};        };\n\n    }",
          "118": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * y[1].[1]))};        };\n\n    }",
          "119": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{(((sGradient[0] * jacobian[0].[0]) + (sGradient[1] * jacobian[1].[0])) + (sGradient[2] * jacobian[0].[0])),(((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])),((sGradient[0] * jacobian[0].[2]) + (sGradient[2] * z[1].[1]))};        };\n\n    }",
          "120": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]};        };\n\n    }",
          "121": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn;\n        return new double[] {\n            sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[0][0],\n            sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1],\n            sGradient[0] * jacobian[0][2]                                 + sGradient[2] * jacobian[2][2]        };\n\n    }",
          "122": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nreturn new double[[]]{((((sGradient[0] * jacobian[0].[1]) + (sGradient[1] * jacobian[1].[1])) + (sGradient[2] * jacobian[2].[1])) + sGradient)};        };\n\n    }",
          "123": "    public double[] toCartesianGradient(final double[] sGradient) {\n\n        // lazy evaluation of Jacobian\n        computeJacobian();\n\n        // compose derivatives as gradient^T . J\n        // the expressions have been simplified since we know jacobian[1][2] = dTheta/dZ = 0\nbreak;\n        return new double[] {\n            sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[0][0],\n            sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1],\n            sGradient[0] * jacobian[0][2]                                 + sGradient[2] * jacobian[2][2]        };\n\n    }"
}