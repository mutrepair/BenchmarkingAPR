{
          "0": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "1": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blocks);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "2": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + rows);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "3": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + columns);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "4": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockRows);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "5": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockColumns);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "6": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal long widthExcess = ((jWidth + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "7": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) - BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "8": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + iHeight);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "9": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + rowsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "10": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((rowsShift + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "11": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((BLOCK_SIZE + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "12": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((iHeight + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "13": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + rowsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "14": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "15": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + iHeight) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "16": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) / BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "17": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = columnsShift;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "18": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = jWidth;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "19": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = columnsShift;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "20": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = jWidth;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "21": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) * BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "22": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + BLOCK_SIZE.jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "23": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + rows.jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "24": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + columns.jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "25": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockRows.jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "26": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockColumns.jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "27": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getRowDimension().jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "28": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getColumnDimension().jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "29": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + BLOCK_SIZE.columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "30": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + rows.columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "31": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + columns.columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "32": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockRows.columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "33": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockColumns.columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "34": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getRowDimension().columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "35": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getColumnDimension().columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "36": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = BLOCK_SIZE;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "37": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = BLOCK_SIZE;\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "38": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + BLOCK_SIZE.BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "39": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + rows.BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "40": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + columns.BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "41": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockRows.BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "42": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + blockColumns.BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "43": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getRowDimension().BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "44": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) + getColumnDimension().BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "45": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((jWidth + columnsShift) + BLOCK_SIZE) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "46": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((jWidth + columnsShift) + BLOCK_SIZE) + jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "47": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((jWidth + columnsShift) + BLOCK_SIZE) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "48": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((jWidth + columnsShift) + BLOCK_SIZE) + jWidth);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "49": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) % BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "50": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "51": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "52": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + jWidth) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "53": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) | BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "54": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) & BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "55": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) == BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "56": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) << BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "57": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + columnsShift) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "58": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + columnsShift) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "59": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int widthExcess = ((jWidth + columnsShift) != BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "60": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + jWidth) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "61": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + jWidth) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "62": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((jWidth + columnsShift) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "63": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((jWidth + columnsShift) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "64": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((columnsShift + BLOCK_SIZE) + columnsShift);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "65": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((columnsShift + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "66": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((columnsShift + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "67": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nreturn;\n                final int widthExcess = jWidth + columnsShift + BLOCK_SIZE;                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "68": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n                final int widthExcess = jWidth + columnsShift + BLOCK_SIZE;                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "69": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((columnsShift + columnsShift) + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "70": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((columnsShift + columnsShift) + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "71": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((jWidth + columnsShift) + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "72": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((jWidth + columnsShift) + columnsShift) + columnsShift) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "73": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((jWidth + columnsShift) + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "74": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((jWidth + columnsShift) + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "75": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((columnsShift + columnsShift) + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "76": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = ((((jWidth + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "77": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((jWidth + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "78": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((jWidth + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "79": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((jWidth + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "80": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((jWidth + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "81": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((columnsShift + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }",
          "82": "    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn,\n                                        final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        // safety checks\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        // create the output matrix\n        final BlockRealMatrix out =\n            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\n        // compute blocks shifts\n        final int blockStartRow = startRow / BLOCK_SIZE;\n        final int rowsShift = startRow % BLOCK_SIZE;\n        final int blockStartColumn = startColumn / BLOCK_SIZE;\n        final int columnsShift = startColumn % BLOCK_SIZE;\n\n        // perform extraction block-wise, to ensure good cache behavior\n        int pBlock = blockStartRow;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n            final int iHeight = out.blockHeight(iBlock);\n            int qBlock = blockStartColumn;\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n\n                // handle one block of the output matrix\n                final int outIndex = iBlock * out.blockColumns + jBlock;\n                final double[] outBlock = out.blocks[outIndex];\n                final int index = pBlock * blockColumns + qBlock;\n                final int width = blockWidth(qBlock);\n\n                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\nfinal int  = (((((columnsShift + columnsShift) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                if (heightExcess > 0) {\n                    // the submatrix block spans on two blocks rows from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, BLOCK_SIZE,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n                                      0, heightExcess,\n                                      0, widthExcess,\n                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, BLOCK_SIZE,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + blockColumns], width,\n                                      0, heightExcess,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, iHeight - heightExcess, 0);\n                    }\n                } else {\n                    // the submatrix block spans on one block row from the original matrix\n                    if (widthExcess > 0) {\n                        // the submatrix block spans on two blocks columns from the original matrix\n                        final int width2 = blockWidth(qBlock + 1);\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, BLOCK_SIZE,\n                                      outBlock, jWidth, 0, 0);\n                        copyBlockPart(blocks[index + 1], width2,\n                                      rowsShift, iHeight + rowsShift,\n                                      0, widthExcess,\n                                      outBlock, jWidth, 0, jWidth - widthExcess);\n                    } else {\n                        // the submatrix block spans on one block column from the original matrix\n                        copyBlockPart(blocks[index], width,\n                                      rowsShift, iHeight + rowsShift,\n                                      columnsShift, jWidth + columnsShift,\n                                      outBlock, jWidth, 0, 0);\n                    }\n               }\n                ++qBlock;\n            }\n            ++pBlock;\n        }\n\n        return out;\n    }"
}