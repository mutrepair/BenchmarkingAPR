{
          "0": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y >= start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "1": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "2": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x > start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "3": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence2.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "4": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(((x >= start1) && (y > start2))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "5": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y <= start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "6": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x <= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "7": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x < start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "8": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y < start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "9": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) || equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "10": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x == start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "11": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y == start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "12": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > y)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "13": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x != start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "14": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y != start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "15": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.buildSnake(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "16": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= y) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "17": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > x)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "18": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y))) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "19": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((x >= start1)){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "20": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(((x >= start1) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "21": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= x) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "22": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > end2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "23": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > vUp)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "24": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > end1)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "25": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((y > start2)){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "26": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x || start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "27": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > k)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "28": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x && start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "29": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && equator.equate(sequence1.get(x), sequence2.get(y))) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "30": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > vDown)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "31": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= end2) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "32": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(equator.equate(sequence1.get(x), sequence2.get(y))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "33": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= end1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "34": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= vUp) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "35": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "36": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(i.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "37": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= k) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "38": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y || start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "39": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y && start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "40": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= vDown) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "41": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "42": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x & start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "43": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.equate(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "44": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y & start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "45": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(((((x >= start1) && (y > start2)) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "46": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && sequence1.equate(x))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "47": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x | start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "48": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y))) && equator.equate(sequence1.get(x), sequence2.get(y))) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "49": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(equator.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "50": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(x))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "51": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.getMiddleSnake(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "52": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y | start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "53": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\ny--;\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "54": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile(((k != (delta + d)) && (vUp[(i + 1)] <= vUp[(i - 1)]))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "55": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nvUp[i] = x--;\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "56": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nvUp[i] = (vUp[(i + 1)] - 1);\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "57": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nvUp[i] = vUp[(i - 1)];\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "58": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y)))){\nvUp[i] = x--;\ny--;\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "59": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.get(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "60": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((delta % 2) == 0) && (-d <= k))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "61": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.e(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "62": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.vUp(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "63": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.add(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "64": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.equate(sequence1.d(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "65": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((x >= start1) && (y > start2)) && equator.debug(sequence1.get(x), sequence2.get(y)))){                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "66": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nwhile((((((x >= start1) && (y > start2)) && (y > start2)) && equator.equate(sequence1.get(x), sequence2.get(y))) && equator.equate(sequence1.get(x), sequence2.get(y)))){\n\n}                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "67": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nreturn;\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "68": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\nbreak;\n                while (x >= start1 && y > start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }"
}