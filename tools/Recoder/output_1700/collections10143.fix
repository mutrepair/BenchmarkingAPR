{
          "0": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "1": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - x) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "2": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - x) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "3": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - x);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "4": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) + k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "5": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nlong y = (((x - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "6": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - end2) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "7": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = ((x - start1) - start2);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "8": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - end2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "9": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) / k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "10": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - end1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "11": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - i) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "12": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - k) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "13": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start2) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "14": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - end2);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "15": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - end1) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "16": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x <= start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "17": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - i) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "18": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - k) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "19": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start1) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "20": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - end1);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "21": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - i);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "22": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - start2);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "23": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x >= start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "24": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) - start1);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "25": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x - start1) - start2) * k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "26": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x == start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "27": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (x - start1);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "28": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x % start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "29": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "30": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nif((x != null)){\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "31": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((end2 - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "32": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nfinal int y = (((x - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "33": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (y < end2);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "34": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nvDown[i] = ++x;\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "35": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((end1 - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "36": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((start1 - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "37": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((start2 - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "38": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n++y;\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "39": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((k - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "40": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nvDown[i] = vDown[(i + 1)];\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "41": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = ((k + start1) - start2);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "42": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x >> start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "43": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (x < end1);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "44": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nif((vUp[(i - delta)] <= vDown[i])){\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "45": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((delta - start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "46": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = ((((x - start1) - start2) - k) - x);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "47": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (vDown[(i - 1)] < vDown[(i + 1)]);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "48": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nif(((k == -d) || ((k != d) && (vDown[(i - 1)] < vDown[(i + 1)])))){\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "49": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nvDown[i] = (vDown[(i - 1)] + 1);\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "50": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nif(((((delta % 2) != 0) && ((delta - d) <= k)) && (k <= (delta + d)))){\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n}\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "51": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = (((x > start1) - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "52": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nfinal int i = (k + offset);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "53": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nreturn;\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "54": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nbreak;\n                int y = x - start1 - start2 - k;\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "55": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = ((x - start1) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "56": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\nint y = ((x - start2) - k);\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }"
}