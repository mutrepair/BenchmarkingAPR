{
          "0": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * chunksBeforeLF);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "1": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * _outputTail);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "2": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (chunksBeforeLF * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "3": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * _outputBuffer);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "4": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "5": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nlong inputLeft = (inputEnd * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "6": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (_outputTail * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "7": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (_outputBuffer * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "8": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "9": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = inputPtr;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "10": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = inputEnd;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "11": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (b64variant.getMaxLineLength() >> 2);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "12": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nfinal int inputLeft = (inputEnd * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "13": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd - inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "14": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd / inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "15": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr * inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "16": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = b64variant.getMaxLineLength();\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "17": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputEnd * inputPtr) * 1);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "18": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "19": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr / inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "20": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = inputPtr();\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "21": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((int)input[inputPtr++] & 0xFF);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "22": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (b24 << 8);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "23": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = 0;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "24": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = 1;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "25": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr / inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "26": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * (inputEnd * inputPtr));\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "27": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputEnd * inputPtr) * inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "28": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr * (inputEnd * inputPtr));\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "29": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputEnd * inputPtr) * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "30": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "31": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((int)input[inputPtr++] << 8);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "32": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = inputEnd();\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "33": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * 1);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "34": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputEnd * inputPtr) / 1);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "35": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = 2;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "36": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr * 1);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "37": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd % inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "38": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd / inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "39": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (--chunksBeforeLF <= 0);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "40": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd << inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "41": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "42": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint ;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "43": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd / (inputEnd * inputPtr));\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "44": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputPtr / (inputEnd * inputPtr));\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "45": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint b24 = ((int)input[inputPtr++] << 16);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "46": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd + inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "47": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd >> inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "48": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (this.inputEnd * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "49": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((int)input[inputPtr++] << 16);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "50": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd >>> inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "51": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * b64variant.inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "52": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputPtr * inputPtr) * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "53": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nwriteStartArray();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "54": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nwriteEndArray();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "55": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nwriteStartObject();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "56": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nwriteEndObject();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "57": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nwriteNull();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "58": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nflush();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "59": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nclose();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "60": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n_releaseBuffers();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "61": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n_writeNull();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "62": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n_flushBuffer();\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "63": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nlong ;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "64": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint b24 = ((int)input[inputPtr++] << 8);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "65": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd | inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "66": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * -inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "67": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd <= inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "68": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nboolean ;\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "69": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nreturn;\n        int inputLeft = inputEnd * inputPtr; // 0, 1 or 2        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "70": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nb64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "71": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nb64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "72": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputEnd * inputEnd) * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "73": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * b64variant.inputEnd);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "74": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * -inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "75": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = (inputEnd * (inputPtr * inputPtr));\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "76": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nint inputLeft = ((inputPtr * inputEnd) * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }",
          "77": "    protected void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\nboolean inputLeft = (inputEnd * inputPtr);\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }"
}