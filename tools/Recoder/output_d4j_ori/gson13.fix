{
          "0": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((last == NUMBER_CHAR_DIGIT) && fitsInLong)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "1": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((value != Long.MIN_VALUE) || negative)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "2": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "3": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) || ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "4": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((last == NUMBER_CHAR_DIGIT)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "5": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((last == NUMBER_CHAR_DIGIT) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "6": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "7": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value >= Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "8": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "9": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value == Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "10": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last >= NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "11": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(isLenient()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "12": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(hasNext()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "13": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(nextBoolean()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "14": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) == negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "15": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((value != Long.MIN_VALUE)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "16": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value <= Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "17": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last != NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "18": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) || (last == NUMBER_CHAR_EXP_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "19": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last <= NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "20": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value > Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "21": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && ((value != Long.MIN_VALUE) || negative)) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "22": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "23": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last > NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "24": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) > negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "25": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((isLenient() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "26": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((hasNext() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "27": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((nextBoolean() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "28": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) != negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "29": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && isLenient())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "30": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && hasNext())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "31": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && nextBoolean())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "32": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((value != Long.MIN_VALUE) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "33": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "34": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && (last == NUMBER_CHAR_EXP_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "35": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && (last == NUMBER_CHAR_EXP_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "36": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && negative) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "37": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(value){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "38": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) < negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "39": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((last == NUMBER_CHAR_DIGIT) && (last == NUMBER_CHAR_EXP_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "40": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && !isLenient())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "41": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && !hasNext())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "42": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && !nextBoolean())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "43": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && !isLenient())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "44": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && !hasNext())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "45": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && !nextBoolean())){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "46": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last < NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "47": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((!isLenient() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "48": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((!hasNext() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "49": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((!nextBoolean() && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "50": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(negative){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "51": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value < Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "52": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) >= negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "53": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((last == NUMBER_CHAR_DIGIT) && fitsInLong))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "54": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) && negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "55": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && ((value != Long.MIN_VALUE) || negative)) && ((value != Long.MIN_VALUE) || negative))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "56": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && (((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "57": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((last == NUMBER_CHAR_EXP_DIGIT)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "58": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((last == NUMBER_CHAR_FRACTION_DIGIT)){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "59": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && (last == NUMBER_CHAR_FRACTION_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "60": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(peekedLong){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "61": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(((last == NUMBER_CHAR_DIGIT) && (last == NUMBER_CHAR_FRACTION_DIGIT))){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "62": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_NONE) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "63": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_BEGIN_OBJECT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "64": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_END_OBJECT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "65": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_BEGIN_ARRAY) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "66": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_END_ARRAY) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "67": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_TRUE) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "68": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_FALSE) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "69": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_NULL) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "70": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_SINGLE_QUOTED) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "71": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_DOUBLE_QUOTED) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "72": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_UNQUOTED) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "73": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_BUFFERED) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "74": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_SINGLE_QUOTED_NAME) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "75": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_DOUBLE_QUOTED_NAME) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "76": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_UNQUOTED_NAME) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "77": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_LONG) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "78": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_NUMBER) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "79": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == PEEKED_EOF) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "80": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_NONE) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "81": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_SIGN) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "82": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DECIMAL) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "83": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_FRACTION_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "84": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_EXP_E) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "85": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_EXP_SIGN) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "86": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_EXP_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "87": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == pos) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "88": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == limit) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "89": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == lineNumber) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "90": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == lineStart) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "91": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == peeked) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "92": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == peekedNumberLength) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "93": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == stack) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "94": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == stackSize) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "95": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == pathIndices) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "96": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(last){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "97": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(!isLenient()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "98": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(!hasNext()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "99": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(!nextBoolean()){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "100": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(PEEKED_LONG){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "101": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) <= negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "102": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(NUMBER_CHAR_DIGIT){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "103": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != value) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "104": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\npos += i;\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "105": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(!value){\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "106": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\npeekedLong = (negative)?value:-value;\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "107": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || value))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "108": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\npeekedNumberLength = i;\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "109": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif(negative){\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n}\n  }",
          "110": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != peekedLong) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "111": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != PEEKED_NUMBER) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "112": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != negative) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "113": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || PEEKED_LONG))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "114": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) || (last == NUMBER_CHAR_EXP_DIGIT))){\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n}\n  }",
          "115": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || peekedLong))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "116": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != PEEKED_LONG) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "117": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || PEEKED_NUMBER))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "118": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || PEEKED_NONE))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "119": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || peeked))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "120": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != PEEKED_NONE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "121": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && value) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "122": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "123": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != peeked) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "124": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && negative) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "125": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last && NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "126": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && peekedLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "127": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && PEEKED_LONG) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "128": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value && Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "129": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == value) && fitsInLong) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
          "130": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif((((last == NUMBER_CHAR_DIGIT) && PEEKED_NUMBER) && ((value != Long.MIN_VALUE) || negative))){      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }"
}