{
          "0": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val >= 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "1": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val <= 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "2": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 2) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "3": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val > 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "4": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 0xFF) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "5": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val < 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "6": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((val << 8) ^<> hash) << 8)){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "7": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) >= 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "8": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((val << 8) ^<> hash)){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "9": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) <= 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "10": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) > 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "11": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((val << 8)){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "12": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val >>> 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "13": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val >> 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "14": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> val) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "15": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "16": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) < 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "17": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 0) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "18": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> ix) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "19": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val == 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "20": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((ix << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "21": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << null) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "22": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) <= hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "23": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << -1) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "24": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) >= hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "25": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) > hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "26": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) < hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "27": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 1) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "28": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) >> 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "29": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val != 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "30": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) >>> 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "31": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) != 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "32": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) & 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "33": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((hash << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "34": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) - 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "35": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((name << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "36": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nval -= 1;\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "37": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> name) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "38": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) >> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "39": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) >>> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "40": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << -2) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "41": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nval &= 0xFF;\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "42": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nrelease();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "43": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nrehash();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "44": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nnukeSymbols();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "45": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nunshareMain();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "46": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nunshareCollision();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "47": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nunshareNames();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "48": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nexpandCollision();\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "49": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> secondQuad) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "50": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> _mainNames) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "51": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> _mainHash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "52": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> _collList) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "53": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) - 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "54": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((secondQuad << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "55": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((_mainNames << 8) ^<> hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "56": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) ^<> hash) << 8) & 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "57": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) == hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "58": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((((val << 8) & hash) << 8) == 0)){            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "59": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) || (val < ix))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "60": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) && (val < ix))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "61": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) || (ix < ix))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "62": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) || (val > ix))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "63": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif(((val < ix) || ((((val << 8) ^<> hash) << 8) == 0))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "64": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) || (val < val))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "65": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nif((((((val << 8) ^<> hash) << 8) == 0) && (ix < ix))){\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "66": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n        int ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\nreturn;\n        if ((((val << 8) ^ hash) << 8) == 0) { // match            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }"
}