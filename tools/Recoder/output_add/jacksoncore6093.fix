{
          "0": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "1": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "2": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] & 0xFF) | ((_buffer[(ptr + 1)] & 0xFF) << 8)) | ((_buffer[(ptr + 2)] & 0xFF) << 16)) | (_buffer[(ptr + 3)] << 24));\n                ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n                    | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr + 3] ^ 255);            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "3": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = (((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "4": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "5": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "6": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 2)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "7": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = (((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "8": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch += ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "9": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] & 0xFF) | ((_buffer[(ptr + 1)] & 0xFF) << 8)) | ((_buffer[(ptr + 2)] & 0xFF) << 16)) | (_buffer[(ptr + 3)] << 24));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "10": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "11": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr += 4;\n                ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n                    | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr + 3] ^ 255);            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "12": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = (_buffer[ptr] << 24);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "13": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 1)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "14": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) - 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "15": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nreturn;\n                ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n                    | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr + 3] ^ 255);            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "16": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = (_buffer[(ptr + 3)] ^<> 255);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "17": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((_buffer[(ptr + 1)] & 0xFF) << 16);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "18": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr += 4;\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "19": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = (_buffer[ptr] << 24);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "20": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((_buffer[(ptr + 1)] & 0xFF) << 8);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "21": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((_buffer[(ptr + 2)] & 0xFF) << 8);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "22": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((_buffer[(ptr + 1)] & 0xFF) << 16);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "23": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = (_buffer[(ptr + 3)] ^<> 255);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "24": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((((_buffer[ptr] & 0xFF) | ((_buffer[(ptr + 1)] & 0xFF) << 8)) | ((_buffer[(ptr + 2)] & 0xFF) << 16)) | (_buffer[(ptr + 3)] << 24));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "25": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = (_buffer[(ptr + 2)] & 0xFF);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "26": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 3)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "27": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\n_ptr = ((_buffer[(ptr + 2)] & 0xFF) << 8);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "28": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[ptr] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "29": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = (ptr + 2);\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "30": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) + 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "31": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 1)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "32": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "33": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_ptr[(ptr + 2)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "34": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] - 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "35": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_ptr[(ptr + 1)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "36": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_ptr[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "37": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_ptr ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "38": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 2)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "39": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] + 0xFF) << 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "40": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) * 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "41": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nch = ((((_buffer[ptr] << 24) | ((_buffer[(ptr + 1)] & 0xFF) << 16)) | ((_buffer[(ptr + 2)] & 0xFF) / 8)) | (_buffer[(ptr + 3)] ^<> 255));\n            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }",
          "42": "\tpublic int read(char[] cbuf, int start, int len)\n        throws IOException\n    {\n        // Already EOF?\n        if (_buffer == null) {\n            return -1;\n        }\n        if (len < 1) {\n            return len;\n        }\n        // Let's then ensure there's enough room...\n        if (start < 0 || (start+len) > cbuf.length) {\n            reportBounds(cbuf, start, len);\n        }\n\n        len += start;\n        int outPtr = start;\n\n        // Ok, first; do we have a surrogate from last round?\n        if (_surrogate != NULL_CHAR) {\n            cbuf[outPtr++] = _surrogate;\n            _surrogate = NULL_CHAR;\n            // No need to load more, already got one char\n        } else {\n            /* Note: we'll try to avoid blocking as much as possible. As a\n             * result, we only need to get 4 bytes for a full char.\n             */\n            int left = (_length - _ptr);\n            if (left < 4) {\n                if (!loadMore(left)) { // (legal) EOF?\n                    return -1;\n                }\n            }\n        }\n\n        main_loop:\n        while (outPtr < len) {\n            int ptr = _ptr;\n            int ch;\n\n            if (_bigEndian) {\nbreak;\n                ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n                    | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr + 3] ^ 255);            } else {\n                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n            }\n            _ptr += 4;\n\n            // Does it need to be split to surrogates?\n            // (also, we can and need to verify illegal chars)\n            if (ch > 0xFFFF) { // need to split into surrogates?\n                if (ch > LAST_VALID_UNICODE_CHAR) {\n                    reportInvalid(ch, outPtr-start,\n                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n                }\n                ch -= 0x10000; // to normalize it starting with 0x0\n                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n                // hmmh. can this ever be 0? (not legal, at least?)\n                ch = (0xDC00 | (ch & 0x03FF));\n                // Room for second part?\n                if (outPtr >= len) { // nope\n                    _surrogate = (char) ch;\n                    break main_loop;\n                }\n            }\n            cbuf[outPtr++] = (char) ch;\n            if (_ptr >= _length) {\n                break main_loop;\n            }\n        }\n\n        len = outPtr - start;\n        _charCount += len;\n        return len;\n    }"
}