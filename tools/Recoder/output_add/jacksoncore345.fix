{
          "0": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 1);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "1": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nreturn;\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "2": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)safeInputEnd >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "3": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "4": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)inputPtr[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "5": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\n_reportBase64EOF();\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "6": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nbreak;\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "7": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)sb[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "8": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> -1);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "9": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nb24 |= ((int)input[inputPtr++] & 0xFF);\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "10": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nb24 = ((b24 << 8) | ((int)input[inputPtr++] & 0xFF));\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "11": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)chunksBeforeLF[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "12": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "13": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)inputEnd[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "14": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)sb >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "15": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nsb.append(\"null\");\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "16": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nencodeBase64Chunk(sb, b24);\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "17": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)chunksBeforeLF >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "18": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 0xFF);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "19": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nchunksBeforeLF = (getMaxLineLength() >> 2);\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "20": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 3);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "21": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)inputPtr >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "22": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)inputEnd >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "23": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 2);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "24": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] - 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "25": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nif((--chunksBeforeLF <= 0)){\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n}\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "26": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nlong b24 = ((int)input[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "27": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\ncontinue;\n            int b24 = ((int)input[inputPtr++]) >>> 8;            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "28": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "29": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] % 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "30": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] <= 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "31": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] / 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "32": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = getMaxLineLength();\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "33": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] >>> 0);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "34": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = ((int)input[inputPtr++] * 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "35": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = input[inputPtr++];\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "36": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = (int)((int)input[inputPtr++] >>> 8);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "37": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.sb.[inputPtr++];\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "38": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.inputPtr.[inputPtr++];\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "39": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.input.[inputPtr++];\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "40": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.inputEnd.[inputPtr++];\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "41": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.sb.[inputPtr++].append(inputEnd[0]);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }",
          "42": "    public String encode(byte[] input, boolean addQuotes)\n    {\n        int inputEnd = input.length;\n        StringBuilder sb;\n        {\n            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n            sb = new StringBuilder(outputLen);\n        }\n        if (addQuotes) {\n            sb.append('\"');\n        }\n\n        int chunksBeforeLF = getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        int inputPtr = 0;\n        int safeInputEnd = inputEnd-3; // to get only full triplets\n\n        while (inputPtr <= safeInputEnd) {\n            // First, mash 3 bytes into lsb of 32-bit int\nint b24 = this.sb.[inputPtr++].append(sb[0]);\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            encodeBase64Chunk(sb, b24);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value, so not really useful...\n                sb.append('\\\\');\n                sb.append('n');\n                chunksBeforeLF = getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            encodeBase64Partial(sb, b24, inputLeft);\n        }\n\n        if (addQuotes) {\n            sb.append('\"');\n        }\n        return sb.toString();\n    }"
}